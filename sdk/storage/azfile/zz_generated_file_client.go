//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/base64"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type fileClient struct {
	con *connection
}

// AbortCopy - Aborts a pending Copy File operation, and leaves a destination file with zero length and full metadata.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) AbortCopy(ctx context.Context, copyID string, fileAbortCopyOptions *FileAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (FileAbortCopyResponse, error) {
	req, err := client.abortCopyCreateRequest(ctx, copyID, fileAbortCopyOptions, leaseAccessConditions)
	if err != nil {
		return FileAbortCopyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileAbortCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return FileAbortCopyResponse{}, client.abortCopyHandleError(resp)
	}
	return client.abortCopyHandleResponse(resp)
}

// abortCopyCreateRequest creates the AbortCopy request.
func (client *fileClient) abortCopyCreateRequest(ctx context.Context, copyID string, fileAbortCopyOptions *FileAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "copy")
	reqQP.Set("copyid", copyID)
	if fileAbortCopyOptions != nil && fileAbortCopyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileAbortCopyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-copy-action", "abort")
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// abortCopyHandleResponse handles the AbortCopy response.
func (client *fileClient) abortCopyHandleResponse(resp *http.Response) (FileAbortCopyResponse, error) {
	result := FileAbortCopyResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileAbortCopyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// abortCopyHandleError handles the AbortCopy error response.
func (client *fileClient) abortCopyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// AcquireLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) AcquireLease(ctx context.Context, options *FileAcquireLeaseOptions) (FileAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, options)
	if err != nil {
		return FileAcquireLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return FileAcquireLeaseResponse{}, client.acquireLeaseHandleError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *fileClient) acquireLeaseCreateRequest(ctx context.Context, options *FileAcquireLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Raw().Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *fileClient) acquireLeaseHandleResponse(resp *http.Response) (FileAcquireLeaseResponse, error) {
	result := FileAcquireLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// acquireLeaseHandleError handles the AcquireLease error response.
func (client *fileClient) acquireLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BreakLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) BreakLease(ctx context.Context, fileBreakLeaseOptions *FileBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (FileBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, fileBreakLeaseOptions, leaseAccessConditions)
	if err != nil {
		return FileBreakLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return FileBreakLeaseResponse{}, client.breakLeaseHandleError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *fileClient) breakLeaseCreateRequest(ctx context.Context, fileBreakLeaseOptions *FileBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if fileBreakLeaseOptions != nil && fileBreakLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileBreakLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "break")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if fileBreakLeaseOptions != nil && fileBreakLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *fileBreakLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *fileClient) breakLeaseHandleResponse(resp *http.Response) (FileBreakLeaseResponse, error) {
	result := FileBreakLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// breakLeaseHandleError handles the BreakLease error response.
func (client *fileClient) breakLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ChangeLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) ChangeLease(ctx context.Context, leaseID string, options *FileChangeLeaseOptions) (FileChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return FileChangeLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileChangeLeaseResponse{}, client.changeLeaseHandleError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *fileClient) changeLeaseCreateRequest(ctx context.Context, leaseID string, options *FileChangeLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "change")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *fileClient) changeLeaseHandleResponse(resp *http.Response) (FileChangeLeaseResponse, error) {
	result := FileChangeLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// changeLeaseHandleError handles the ChangeLease error response.
func (client *fileClient) changeLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Create - Creates a new file or replaces a file. Note it only initializes the file with no content.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) Create(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, fileCreateOptions *FileCreateOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (FileCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, fileContentLength, fileAttributes, fileCreationTime, fileLastWriteTime, fileCreateOptions, fileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return FileCreateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return FileCreateResponse{}, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *fileClient) createCreateRequest(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, fileCreateOptions *FileCreateOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileCreateOptions != nil && fileCreateOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileCreateOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("x-ms-content-length", strconv.FormatInt(fileContentLength, 10))
	req.Raw().Header.Set("x-ms-type", "file")
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *fileHTTPHeaders.FileContentType)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *fileHTTPHeaders.FileContentEncoding)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *fileHTTPHeaders.FileContentLanguage)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileCacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *fileHTTPHeaders.FileCacheControl)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentMD5 != nil {
		req.Raw().Header.Set("x-ms-content-md5", base64.StdEncoding.EncodeToString(fileHTTPHeaders.FileContentMD5))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *fileHTTPHeaders.FileContentDisposition)
	}
	if fileCreateOptions != nil && fileCreateOptions.Metadata != nil {
		for k, v := range fileCreateOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if fileCreateOptions != nil && fileCreateOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileCreateOptions.FilePermission)
	}
	if fileCreateOptions != nil && fileCreateOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileCreateOptions.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime.Format(time.RFC1123))
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime.Format(time.RFC1123))
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *fileClient) createHandleResponse(resp *http.Response) (FileCreateResponse, error) {
	result := FileCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileCreateResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// createHandleError handles the Create error response.
func (client *fileClient) createHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - removes the file from the storage account.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) Delete(ctx context.Context, fileDeleteOptions *FileDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (FileDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, fileDeleteOptions, leaseAccessConditions)
	if err != nil {
		return FileDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return FileDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *fileClient) deleteCreateRequest(ctx context.Context, fileDeleteOptions *FileDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileDeleteOptions != nil && fileDeleteOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileDeleteOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *fileClient) deleteHandleResponse(resp *http.Response) (FileDeleteResponse, error) {
	result := FileDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *fileClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Download - Reads or downloads a file from the system, including its metadata and properties.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) Download(ctx context.Context, fileDownloadOptions *FileDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (FileDownloadResponse, error) {
	req, err := client.downloadCreateRequest(ctx, fileDownloadOptions, leaseAccessConditions)
	if err != nil {
		return FileDownloadResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileDownloadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusPartialContent) {
		return FileDownloadResponse{}, client.downloadHandleError(resp)
	}
	return client.downloadHandleResponse(resp)
}

// downloadCreateRequest creates the Download request.
func (client *fileClient) downloadCreateRequest(ctx context.Context, fileDownloadOptions *FileDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileDownloadOptions != nil && fileDownloadOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileDownloadOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if fileDownloadOptions != nil && fileDownloadOptions.Range != nil {
		req.Raw().Header.Set("x-ms-range", *fileDownloadOptions.Range)
	}
	if fileDownloadOptions != nil && fileDownloadOptions.RangeGetContentMD5 != nil {
		req.Raw().Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*fileDownloadOptions.RangeGetContentMD5))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *fileClient) downloadHandleResponse(resp *http.Response) (FileDownloadResponse, error) {
	result := FileDownloadResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-content-md5"); val != "" {
		fileContentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.FileContentMD5 = fileContentMD5
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileDownloadResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// downloadHandleError handles the Download error response.
func (client *fileClient) downloadHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ForceCloseHandles - Closes all handles open for given file
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) ForceCloseHandles(ctx context.Context, handleID string, options *FileForceCloseHandlesOptions) (FileForceCloseHandlesResponse, error) {
	req, err := client.forceCloseHandlesCreateRequest(ctx, handleID, options)
	if err != nil {
		return FileForceCloseHandlesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileForceCloseHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileForceCloseHandlesResponse{}, client.forceCloseHandlesHandleError(resp)
	}
	return client.forceCloseHandlesHandleResponse(resp)
}

// forceCloseHandlesCreateRequest creates the ForceCloseHandles request.
func (client *fileClient) forceCloseHandlesCreateRequest(ctx context.Context, handleID string, options *FileForceCloseHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "forceclosehandles")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-handle-id", handleID)
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// forceCloseHandlesHandleResponse handles the ForceCloseHandles response.
func (client *fileClient) forceCloseHandlesHandleResponse(resp *http.Response) (FileForceCloseHandlesResponse, error) {
	result := FileForceCloseHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileForceCloseHandlesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-marker"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-number-of-handles-closed"); val != "" {
		numberOfHandlesClosed32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesClosed := int32(numberOfHandlesClosed32)
		if err != nil {
			return FileForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesClosed = &numberOfHandlesClosed
	}
	if val := resp.Header.Get("x-ms-number-of-handles-failed"); val != "" {
		numberOfHandlesFailedToClose32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesFailedToClose := int32(numberOfHandlesFailedToClose32)
		if err != nil {
			return FileForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesFailedToClose = &numberOfHandlesFailedToClose
	}
	return result, nil
}

// forceCloseHandlesHandleError handles the ForceCloseHandles error response.
func (client *fileClient) forceCloseHandlesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetProperties - Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It does not return the content of the
// file.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) GetProperties(ctx context.Context, fileGetPropertiesOptions *FileGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (FileGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, fileGetPropertiesOptions, leaseAccessConditions)
	if err != nil {
		return FileGetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileGetPropertiesResponse{}, client.getPropertiesHandleError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *fileClient) getPropertiesCreateRequest(ctx context.Context, fileGetPropertiesOptions *FileGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileGetPropertiesOptions != nil && fileGetPropertiesOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *fileGetPropertiesOptions.Sharesnapshot)
	}
	if fileGetPropertiesOptions != nil && fileGetPropertiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileGetPropertiesOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *fileClient) getPropertiesHandleResponse(resp *http.Response) (FileGetPropertiesResponse, error) {
	result := FileGetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-type"); val != "" {
		result.FileType = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetPropertiesResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// getPropertiesHandleError handles the GetProperties error response.
func (client *fileClient) getPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRangeList - Returns the list of valid ranges for a file.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) GetRangeList(ctx context.Context, fileGetRangeListOptions *FileGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (FileGetRangeListResponse, error) {
	req, err := client.getRangeListCreateRequest(ctx, fileGetRangeListOptions, leaseAccessConditions)
	if err != nil {
		return FileGetRangeListResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileGetRangeListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileGetRangeListResponse{}, client.getRangeListHandleError(resp)
	}
	return client.getRangeListHandleResponse(resp)
}

// getRangeListCreateRequest creates the GetRangeList request.
func (client *fileClient) getRangeListCreateRequest(ctx context.Context, fileGetRangeListOptions *FileGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "rangelist")
	if fileGetRangeListOptions != nil && fileGetRangeListOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *fileGetRangeListOptions.Sharesnapshot)
	}
	if fileGetRangeListOptions != nil && fileGetRangeListOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileGetRangeListOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if fileGetRangeListOptions != nil && fileGetRangeListOptions.Range != nil {
		req.Raw().Header.Set("x-ms-range", *fileGetRangeListOptions.Range)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getRangeListHandleResponse handles the GetRangeList response.
func (client *fileClient) getRangeListHandleResponse(resp *http.Response) (FileGetRangeListResponse, error) {
	result := FileGetRangeListResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetRangeListResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-content-length"); val != "" {
		fileContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return FileGetRangeListResponse{}, err
		}
		result.FileContentLength = &fileContentLength
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileGetRangeListResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return FileGetRangeListResponse{}, err
	}
	return result, nil
}

// getRangeListHandleError handles the GetRangeList error response.
func (client *fileClient) getRangeListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHandles - Lists handles for file
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) ListHandles(ctx context.Context, options *FileListHandlesOptions) (FileListHandlesResponse, error) {
	req, err := client.listHandlesCreateRequest(ctx, options)
	if err != nil {
		return FileListHandlesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileListHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileListHandlesResponse{}, client.listHandlesHandleError(resp)
	}
	return client.listHandlesHandleResponse(resp)
}

// listHandlesCreateRequest creates the ListHandles request.
func (client *fileClient) listHandlesCreateRequest(ctx context.Context, options *FileListHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "listhandles")
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// listHandlesHandleResponse handles the ListHandles response.
func (client *fileClient) listHandlesHandleResponse(resp *http.Response) (FileListHandlesResponse, error) {
	result := FileListHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileListHandlesResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListHandlesResponse); err != nil {
		return FileListHandlesResponse{}, err
	}
	return result, nil
}

// listHandlesHandleError handles the ListHandles error response.
func (client *fileClient) listHandlesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ReleaseLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) ReleaseLease(ctx context.Context, leaseID string, options *FileReleaseLeaseOptions) (FileReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return FileReleaseLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileReleaseLeaseResponse{}, client.releaseLeaseHandleError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *fileClient) releaseLeaseCreateRequest(ctx context.Context, leaseID string, options *FileReleaseLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "release")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *fileClient) releaseLeaseHandleResponse(resp *http.Response) (FileReleaseLeaseResponse, error) {
	result := FileReleaseLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// releaseLeaseHandleError handles the ReleaseLease error response.
func (client *fileClient) releaseLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetHTTPHeaders - Sets HTTP headers on the file.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) SetHTTPHeaders(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, fileSetHTTPHeadersOptions *FileSetHTTPHeadersOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (FileSetHTTPHeadersResponse, error) {
	req, err := client.setHTTPHeadersCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, fileSetHTTPHeadersOptions, fileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return FileSetHTTPHeadersResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileSetHTTPHeadersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileSetHTTPHeadersResponse{}, client.setHTTPHeadersHandleError(resp)
	}
	return client.setHTTPHeadersHandleResponse(resp)
}

// setHTTPHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *fileClient) setHTTPHeadersCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, fileSetHTTPHeadersOptions *FileSetHTTPHeadersOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	if fileSetHTTPHeadersOptions != nil && fileSetHTTPHeadersOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileSetHTTPHeadersOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if fileSetHTTPHeadersOptions != nil && fileSetHTTPHeadersOptions.FileContentLength != nil {
		req.Raw().Header.Set("x-ms-content-length", strconv.FormatInt(*fileSetHTTPHeadersOptions.FileContentLength, 10))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *fileHTTPHeaders.FileContentType)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *fileHTTPHeaders.FileContentEncoding)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *fileHTTPHeaders.FileContentLanguage)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileCacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *fileHTTPHeaders.FileCacheControl)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentMD5 != nil {
		req.Raw().Header.Set("x-ms-content-md5", base64.StdEncoding.EncodeToString(fileHTTPHeaders.FileContentMD5))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *fileHTTPHeaders.FileContentDisposition)
	}
	if fileSetHTTPHeadersOptions != nil && fileSetHTTPHeadersOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileSetHTTPHeadersOptions.FilePermission)
	}
	if fileSetHTTPHeadersOptions != nil && fileSetHTTPHeadersOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileSetHTTPHeadersOptions.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime.Format(time.RFC1123))
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime.Format(time.RFC1123))
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setHTTPHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *fileClient) setHTTPHeadersHandleResponse(resp *http.Response) (FileSetHTTPHeadersResponse, error) {
	result := FileSetHTTPHeadersResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetHTTPHeadersResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// setHTTPHeadersHandleError handles the SetHTTPHeaders error response.
func (client *fileClient) setHTTPHeadersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetMetadata - Updates user-defined metadata for the specified file.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) SetMetadata(ctx context.Context, fileSetMetadataOptions *FileSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (FileSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, fileSetMetadataOptions, leaseAccessConditions)
	if err != nil {
		return FileSetMetadataResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FileSetMetadataResponse{}, client.setMetadataHandleError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *fileClient) setMetadataCreateRequest(ctx context.Context, fileSetMetadataOptions *FileSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "metadata")
	if fileSetMetadataOptions != nil && fileSetMetadataOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileSetMetadataOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if fileSetMetadataOptions != nil && fileSetMetadataOptions.Metadata != nil {
		for k, v := range fileSetMetadataOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *fileClient) setMetadataHandleResponse(resp *http.Response) (FileSetMetadataResponse, error) {
	result := FileSetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// setMetadataHandleError handles the SetMetadata error response.
func (client *fileClient) setMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StartCopy - Copies a file or file to a destination file within the storage account.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) StartCopy(ctx context.Context, copySource string, fileStartCopyOptions *FileStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (FileStartCopyResponse, error) {
	req, err := client.startCopyCreateRequest(ctx, copySource, fileStartCopyOptions, copyFileSmbInfo, leaseAccessConditions)
	if err != nil {
		return FileStartCopyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileStartCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return FileStartCopyResponse{}, client.startCopyHandleError(resp)
	}
	return client.startCopyHandleResponse(resp)
}

// startCopyCreateRequest creates the StartCopy request.
func (client *fileClient) startCopyCreateRequest(ctx context.Context, copySource string, fileStartCopyOptions *FileStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileStartCopyOptions != nil && fileStartCopyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileStartCopyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if fileStartCopyOptions != nil && fileStartCopyOptions.Metadata != nil {
		for k, v := range fileStartCopyOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if fileStartCopyOptions != nil && fileStartCopyOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileStartCopyOptions.FilePermission)
	}
	if fileStartCopyOptions != nil && fileStartCopyOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileStartCopyOptions.FilePermissionKey)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FilePermissionCopyMode != nil {
		req.Raw().Header.Set("x-ms-file-permission-copy-mode", string(*copyFileSmbInfo.FilePermissionCopyMode))
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.IgnoreReadOnly != nil {
		req.Raw().Header.Set("x-ms-file-copy-ignore-read-only", strconv.FormatBool(*copyFileSmbInfo.IgnoreReadOnly))
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileAttributes != nil {
		req.Raw().Header.Set("x-ms-file-attributes", *copyFileSmbInfo.FileAttributes)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileCreationTime != nil {
		req.Raw().Header.Set("x-ms-file-creation-time", *copyFileSmbInfo.FileCreationTime)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileLastWriteTime != nil {
		req.Raw().Header.Set("x-ms-file-last-write-time", *copyFileSmbInfo.FileLastWriteTime)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.SetArchiveAttribute != nil {
		req.Raw().Header.Set("x-ms-file-copy-set-archive", strconv.FormatBool(*copyFileSmbInfo.SetArchiveAttribute))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// startCopyHandleResponse handles the StartCopy response.
func (client *fileClient) startCopyHandleResponse(resp *http.Response) (FileStartCopyResponse, error) {
	result := FileStartCopyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileStartCopyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileStartCopyResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return result, nil
}

// startCopyHandleError handles the StartCopy error response.
func (client *fileClient) startCopyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UploadRange - Upload a range of bytes to a file.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) UploadRange(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, fileUploadRangeOptions *FileUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (FileUploadRangeResponse, error) {
	req, err := client.uploadRangeCreateRequest(ctx, rangeParam, fileRangeWrite, contentLength, fileUploadRangeOptions, leaseAccessConditions)
	if err != nil {
		return FileUploadRangeResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileUploadRangeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return FileUploadRangeResponse{}, client.uploadRangeHandleError(resp)
	}
	return client.uploadRangeHandleResponse(resp)
}

// uploadRangeCreateRequest creates the UploadRange request.
func (client *fileClient) uploadRangeCreateRequest(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, fileUploadRangeOptions *FileUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if fileUploadRangeOptions != nil && fileUploadRangeOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileUploadRangeOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-range", rangeParam)
	req.Raw().Header.Set("x-ms-write", string(fileRangeWrite))
	req.Raw().Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if fileUploadRangeOptions != nil && fileUploadRangeOptions.ContentMD5 != nil {
		req.Raw().Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(fileUploadRangeOptions.ContentMD5))
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	if fileUploadRangeOptions != nil && fileUploadRangeOptions.Optionalbody != nil {
		return req, req.SetBody(fileUploadRangeOptions.Optionalbody, "application/octet-stream")
	}
	return req, nil
}

// uploadRangeHandleResponse handles the UploadRange response.
func (client *fileClient) uploadRangeHandleResponse(resp *http.Response) (FileUploadRangeResponse, error) {
	result := FileUploadRangeResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileUploadRangeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return FileUploadRangeResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileUploadRangeResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileUploadRangeResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// uploadRangeHandleError handles the UploadRange error response.
func (client *fileClient) uploadRangeHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UploadRangeFromURL - Upload a range of bytes to a file where the contents are read from a URL.
// If the operation fails it returns the *StorageError error type.
func (client *fileClient) UploadRangeFromURL(ctx context.Context, rangeParam string, copySource string, contentLength int64, fileUploadRangeFromURLOptions *FileUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (FileUploadRangeFromURLResponse, error) {
	req, err := client.uploadRangeFromURLCreateRequest(ctx, rangeParam, copySource, contentLength, fileUploadRangeFromURLOptions, sourceModifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return FileUploadRangeFromURLResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FileUploadRangeFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return FileUploadRangeFromURLResponse{}, client.uploadRangeFromURLHandleError(resp)
	}
	return client.uploadRangeFromURLHandleResponse(resp)
}

// uploadRangeFromURLCreateRequest creates the UploadRangeFromURL request.
func (client *fileClient) uploadRangeFromURLCreateRequest(ctx context.Context, rangeParam string, copySource string, contentLength int64, fileUploadRangeFromURLOptions *FileUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if fileUploadRangeFromURLOptions != nil && fileUploadRangeFromURLOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileUploadRangeFromURLOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-range", rangeParam)
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if fileUploadRangeFromURLOptions != nil && fileUploadRangeFromURLOptions.SourceRange != nil {
		req.Raw().Header.Set("x-ms-source-range", *fileUploadRangeFromURLOptions.SourceRange)
	}
	req.Raw().Header.Set("x-ms-write", "update")
	req.Raw().Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if fileUploadRangeFromURLOptions != nil && fileUploadRangeFromURLOptions.SourceContentCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-content-crc64", base64.StdEncoding.EncodeToString(fileUploadRangeFromURLOptions.SourceContentCRC64))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatchCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-if-match-crc64", base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfMatchCRC64))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatchCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match-crc64", base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfNoneMatchCRC64))
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// uploadRangeFromURLHandleResponse handles the UploadRangeFromURL response.
func (client *fileClient) uploadRangeFromURLHandleResponse(resp *http.Response) (FileUploadRangeFromURLResponse, error) {
	result := FileUploadRangeFromURLResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileUploadRangeFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return FileUploadRangeFromURLResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return FileUploadRangeFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return FileUploadRangeFromURLResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// uploadRangeFromURLHandleError handles the UploadRangeFromURL error response.
func (client *fileClient) uploadRangeFromURLHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
