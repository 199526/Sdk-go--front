//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type fileClient struct {
	endpoint string
	pl       runtime.Pipeline
}

// newFileClient creates a new instance of fileClient with the specified values.
// endpoint - The URL of the service account, share, directory or file that is the target of the desired operation.
// pl - the pipeline used for sending requests and handling responses.
func newFileClient(endpoint string, pl runtime.Pipeline) *fileClient {
	client := &fileClient{
		endpoint: endpoint,
		pl:       pl,
	}
	return client
}

// AbortCopy - Aborts a pending Copy File operation, and leaves a destination file with zero length and full metadata.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// copyID - The copy identifier provided in the x-ms-copy-id header of the original Copy File operation.
// options - fileClientAbortCopyOptions contains the optional parameters for the fileClient.AbortCopy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) AbortCopy(ctx context.Context, copyID string, options *fileClientAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientAbortCopyResponse, error) {
	req, err := client.abortCopyCreateRequest(ctx, copyID, options, leaseAccessConditions)
	if err != nil {
		return fileClientAbortCopyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientAbortCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return fileClientAbortCopyResponse{}, runtime.NewResponseError(resp)
	}
	return client.abortCopyHandleResponse(resp)
}

// abortCopyCreateRequest creates the AbortCopy request.
func (client *fileClient) abortCopyCreateRequest(ctx context.Context, copyID string, options *fileClientAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "copy")
	reqQP.Set("copyid", copyID)
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-copy-action"] = []string{"abort"}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// abortCopyHandleResponse handles the AbortCopy response.
func (client *fileClient) abortCopyHandleResponse(resp *http.Response) (fileClientAbortCopyResponse, error) {
	result := fileClientAbortCopyResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAbortCopyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// AcquireLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientAcquireLeaseOptions contains the optional parameters for the fileClient.AcquireLease method.
func (client *fileClient) AcquireLease(ctx context.Context, options *fileClientAcquireLeaseOptions) (fileClientAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, options)
	if err != nil {
		return fileClientAcquireLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientAcquireLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *fileClient) acquireLeaseCreateRequest(ctx context.Context, options *fileClientAcquireLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"acquire"}
	if options != nil && options.Duration != nil {
		req.Raw().Header["x-ms-lease-duration"] = []string{strconv.FormatInt(int64(*options.Duration), 10)}
	}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header["x-ms-proposed-lease-id"] = []string{*options.ProposedLeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *fileClient) acquireLeaseHandleResponse(resp *http.Response) (fileClientAcquireLeaseResponse, error) {
	result := fileClientAcquireLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// BreakLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientBreakLeaseOptions contains the optional parameters for the fileClient.BreakLease method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) BreakLease(ctx context.Context, options *fileClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientBreakLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientBreakLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *fileClient) breakLeaseCreateRequest(ctx context.Context, options *fileClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"break"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *fileClient) breakLeaseHandleResponse(resp *http.Response) (fileClientBreakLeaseResponse, error) {
	result := fileClientBreakLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// ChangeLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// leaseID - Specifies the current lease ID on the resource.
// options - fileClientChangeLeaseOptions contains the optional parameters for the fileClient.ChangeLease method.
func (client *fileClient) ChangeLease(ctx context.Context, leaseID string, options *fileClientChangeLeaseOptions) (fileClientChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return fileClientChangeLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientChangeLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *fileClient) changeLeaseCreateRequest(ctx context.Context, leaseID string, options *fileClientChangeLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"change"}
	req.Raw().Header["x-ms-lease-id"] = []string{leaseID}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header["x-ms-proposed-lease-id"] = []string{*options.ProposedLeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *fileClient) changeLeaseHandleResponse(resp *http.Response) (fileClientChangeLeaseResponse, error) {
	result := fileClientChangeLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Create - Creates a new file or replaces a file. Note it only initializes the file with no content.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// fileContentLength - Specifies the maximum size for the file, up to 4 TB.
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// options - fileClientCreateOptions contains the optional parameters for the fileClient.Create method.
// ShareFileHTTPHeaders - ShareFileHTTPHeaders contains a group of parameters for the fileClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Create(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *fileClientCreateOptions, shareFileHTTPHeaders *ShareFileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (fileClientCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, fileContentLength, fileAttributes, fileCreationTime, fileLastWriteTime, options, shareFileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return fileClientCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *fileClient) createCreateRequest(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *fileClientCreateOptions, shareFileHTTPHeaders *ShareFileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["x-ms-content-length"] = []string{strconv.FormatInt(fileContentLength, 10)}
	req.Raw().Header["x-ms-type"] = []string{"file"}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentType != nil {
		req.Raw().Header["x-ms-content-type"] = []string{*shareFileHTTPHeaders.ContentType}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentEncoding != nil {
		req.Raw().Header["x-ms-content-encoding"] = []string{*shareFileHTTPHeaders.ContentEncoding}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentLanguage != nil {
		req.Raw().Header["x-ms-content-language"] = []string{*shareFileHTTPHeaders.ContentLanguage}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.CacheControl != nil {
		req.Raw().Header["x-ms-cache-control"] = []string{*shareFileHTTPHeaders.CacheControl}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentMD5 != nil {
		req.Raw().Header["x-ms-content-md5"] = []string{base64.StdEncoding.EncodeToString(shareFileHTTPHeaders.ContentMD5)}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentDisposition != nil {
		req.Raw().Header["x-ms-content-disposition"] = []string{*shareFileHTTPHeaders.ContentDisposition}
	}
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	if options != nil && options.FilePermission != nil {
		req.Raw().Header["x-ms-file-permission"] = []string{*options.FilePermission}
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header["x-ms-file-permission-key"] = []string{*options.FilePermissionKey}
	}
	req.Raw().Header["x-ms-file-attributes"] = []string{fileAttributes}
	req.Raw().Header["x-ms-file-creation-time"] = []string{fileCreationTime}
	req.Raw().Header["x-ms-file-last-write-time"] = []string{fileLastWriteTime}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *fileClient) createHandleResponse(resp *http.Response) (fileClientCreateResponse, error) {
	result := fileClientCreateResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// Delete - removes the file from the storage account.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientDeleteOptions contains the optional parameters for the fileClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Delete(ctx context.Context, options *fileClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *fileClient) deleteCreateRequest(ctx context.Context, options *fileClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *fileClient) deleteHandleResponse(resp *http.Response) (fileClientDeleteResponse, error) {
	result := fileClientDeleteResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Download - Reads or downloads a file from the system, including its metadata and properties.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientDownloadOptions contains the optional parameters for the fileClient.Download method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Download(ctx context.Context, options *fileClientDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientDownloadResponse, error) {
	req, err := client.downloadCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientDownloadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientDownloadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusPartialContent) {
		return fileClientDownloadResponse{}, runtime.NewResponseError(resp)
	}
	return client.downloadHandleResponse(resp)
}

// downloadCreateRequest creates the Download request.
func (client *fileClient) downloadCreateRequest(ctx context.Context, options *fileClientDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	if options != nil && options.RangeGetContentMD5 != nil {
		req.Raw().Header["x-ms-range-get-content-md5"] = []string{strconv.FormatBool(*options.RangeGetContentMD5)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *fileClient) downloadHandleResponse(resp *http.Response) (fileClientDownloadResponse, error) {
	result := fileClientDownloadResponse{Body: resp.Body}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-content-md5"); val != "" {
		fileContentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.FileContentMD5 = fileContentMD5
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// ForceCloseHandles - Closes all handles open for given file
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// handleID - Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is a wildcard that specifies
// all handles.
// options - fileClientForceCloseHandlesOptions contains the optional parameters for the fileClient.ForceCloseHandles method.
func (client *fileClient) ForceCloseHandles(ctx context.Context, handleID string, options *fileClientForceCloseHandlesOptions) (fileClientForceCloseHandlesResponse, error) {
	req, err := client.forceCloseHandlesCreateRequest(ctx, handleID, options)
	if err != nil {
		return fileClientForceCloseHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientForceCloseHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientForceCloseHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.forceCloseHandlesHandleResponse(resp)
}

// forceCloseHandlesCreateRequest creates the ForceCloseHandles request.
func (client *fileClient) forceCloseHandlesCreateRequest(ctx context.Context, handleID string, options *fileClientForceCloseHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "forceclosehandles")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-handle-id"] = []string{handleID}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// forceCloseHandlesHandleResponse handles the ForceCloseHandles response.
func (client *fileClient) forceCloseHandlesHandleResponse(resp *http.Response) (fileClientForceCloseHandlesResponse, error) {
	result := fileClientForceCloseHandlesResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-marker"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-number-of-handles-closed"); val != "" {
		numberOfHandlesClosed32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesClosed := int32(numberOfHandlesClosed32)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesClosed = &numberOfHandlesClosed
	}
	if val := resp.Header.Get("x-ms-number-of-handles-failed"); val != "" {
		numberOfHandlesFailedToClose32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesFailedToClose := int32(numberOfHandlesFailedToClose32)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesFailedToClose = &numberOfHandlesFailedToClose
	}
	return result, nil
}

// GetProperties - Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It does
// not return the content of the file.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientGetPropertiesOptions contains the optional parameters for the fileClient.GetProperties method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) GetProperties(ctx context.Context, options *fileClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *fileClient) getPropertiesCreateRequest(ctx context.Context, options *fileClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *fileClient) getPropertiesHandleResponse(resp *http.Response) (fileClientGetPropertiesResponse, error) {
	result := fileClientGetPropertiesResponse{}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-type"); val != "" {
		result.FileType = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// GetRangeList - Returns the list of valid ranges for a file.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientGetRangeListOptions contains the optional parameters for the fileClient.GetRangeList method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) GetRangeList(ctx context.Context, options *fileClientGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientGetRangeListResponse, error) {
	req, err := client.getRangeListCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientGetRangeListResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRangeListHandleResponse(resp)
}

// getRangeListCreateRequest creates the GetRangeList request.
func (client *fileClient) getRangeListCreateRequest(ctx context.Context, options *fileClientGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "rangelist")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Prevsharesnapshot != nil {
		reqQP.Set("prevsharesnapshot", *options.Prevsharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.Range != nil {
		req.Raw().Header["x-ms-range"] = []string{*options.Range}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getRangeListHandleResponse handles the GetRangeList response.
func (client *fileClient) getRangeListHandleResponse(resp *http.Response) (fileClientGetRangeListResponse, error) {
	result := fileClientGetRangeListResponse{}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-content-length"); val != "" {
		fileContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.FileContentLength = &fileContentLength
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ShareFileRangeList); err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	return result, nil
}

// ListHandles - Lists handles for file
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientListHandlesOptions contains the optional parameters for the fileClient.ListHandles method.
func (client *fileClient) ListHandles(ctx context.Context, options *fileClientListHandlesOptions) (fileClientListHandlesResponse, error) {
	req, err := client.listHandlesCreateRequest(ctx, options)
	if err != nil {
		return fileClientListHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientListHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientListHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHandlesHandleResponse(resp)
}

// listHandlesCreateRequest creates the ListHandles request.
func (client *fileClient) listHandlesCreateRequest(ctx context.Context, options *fileClientListHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "listhandles")
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listHandlesHandleResponse handles the ListHandles response.
func (client *fileClient) listHandlesHandleResponse(resp *http.Response) (fileClientListHandlesResponse, error) {
	result := fileClientListHandlesResponse{}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientListHandlesResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListHandlesResponse); err != nil {
		return fileClientListHandlesResponse{}, err
	}
	return result, nil
}

// ReleaseLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// leaseID - Specifies the current lease ID on the resource.
// options - fileClientReleaseLeaseOptions contains the optional parameters for the fileClient.ReleaseLease method.
func (client *fileClient) ReleaseLease(ctx context.Context, leaseID string, options *fileClientReleaseLeaseOptions) (fileClientReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return fileClientReleaseLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientReleaseLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *fileClient) releaseLeaseCreateRequest(ctx context.Context, leaseID string, options *fileClientReleaseLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"release"}
	req.Raw().Header["x-ms-lease-id"] = []string{leaseID}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *fileClient) releaseLeaseHandleResponse(resp *http.Response) (fileClientReleaseLeaseResponse, error) {
	result := fileClientReleaseLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetHTTPHeaders - Sets HTTP headers on the file.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// options - fileClientSetHTTPHeadersOptions contains the optional parameters for the fileClient.SetHTTPHeaders method.
// ShareFileHTTPHeaders - ShareFileHTTPHeaders contains a group of parameters for the fileClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) SetHTTPHeaders(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *fileClientSetHTTPHeadersOptions, shareFileHTTPHeaders *ShareFileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (fileClientSetHTTPHeadersResponse, error) {
	req, err := client.setHTTPHeadersCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, options, shareFileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return fileClientSetHTTPHeadersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientSetHTTPHeadersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientSetHTTPHeadersResponse{}, runtime.NewResponseError(resp)
	}
	return client.setHTTPHeadersHandleResponse(resp)
}

// setHTTPHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *fileClient) setHTTPHeadersCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *fileClientSetHTTPHeadersOptions, shareFileHTTPHeaders *ShareFileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.FileContentLength != nil {
		req.Raw().Header["x-ms-content-length"] = []string{strconv.FormatInt(*options.FileContentLength, 10)}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentType != nil {
		req.Raw().Header["x-ms-content-type"] = []string{*shareFileHTTPHeaders.ContentType}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentEncoding != nil {
		req.Raw().Header["x-ms-content-encoding"] = []string{*shareFileHTTPHeaders.ContentEncoding}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentLanguage != nil {
		req.Raw().Header["x-ms-content-language"] = []string{*shareFileHTTPHeaders.ContentLanguage}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.CacheControl != nil {
		req.Raw().Header["x-ms-cache-control"] = []string{*shareFileHTTPHeaders.CacheControl}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentMD5 != nil {
		req.Raw().Header["x-ms-content-md5"] = []string{base64.StdEncoding.EncodeToString(shareFileHTTPHeaders.ContentMD5)}
	}
	if shareFileHTTPHeaders != nil && shareFileHTTPHeaders.ContentDisposition != nil {
		req.Raw().Header["x-ms-content-disposition"] = []string{*shareFileHTTPHeaders.ContentDisposition}
	}
	if options != nil && options.FilePermission != nil {
		req.Raw().Header["x-ms-file-permission"] = []string{*options.FilePermission}
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header["x-ms-file-permission-key"] = []string{*options.FilePermissionKey}
	}
	req.Raw().Header["x-ms-file-attributes"] = []string{fileAttributes}
	req.Raw().Header["x-ms-file-creation-time"] = []string{fileCreationTime}
	req.Raw().Header["x-ms-file-last-write-time"] = []string{fileLastWriteTime}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setHTTPHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *fileClient) setHTTPHeadersHandleResponse(resp *http.Response) (fileClientSetHTTPHeadersResponse, error) {
	result := fileClientSetHTTPHeadersResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// SetMetadata - Updates user-defined metadata for the specified file.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - fileClientSetMetadataOptions contains the optional parameters for the fileClient.SetMetadata method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) SetMetadata(ctx context.Context, options *fileClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return fileClientSetMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientSetMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *fileClient) setMetadataCreateRequest(ctx context.Context, options *fileClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *fileClient) setMetadataHandleResponse(resp *http.Response) (fileClientSetMetadataResponse, error) {
	result := fileClientSetMetadataResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	return result, nil
}

// StartCopy - Copies a blob or file to a destination file within the storage account.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// copySource - Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file to another file within
// the same storage account, you may use Shared Key to authenticate the source file. If you are
// copying a file from another storage account, or if you are copying a blob from the same storage account or another storage
// account, then you must authenticate the source file or blob using a shared
// access signature. If the source is a public blob, no authentication is required to perform the copy operation. A file in
// a share snapshot can also be specified as a copy source.
// options - fileClientStartCopyOptions contains the optional parameters for the fileClient.StartCopy method.
// CopyFileSmbInfo - CopyFileSmbInfo contains a group of parameters for the fileClient.StartCopy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) StartCopy(ctx context.Context, copySource string, options *fileClientStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (fileClientStartCopyResponse, error) {
	req, err := client.startCopyCreateRequest(ctx, copySource, options, copyFileSmbInfo, leaseAccessConditions)
	if err != nil {
		return fileClientStartCopyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientStartCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientStartCopyResponse{}, runtime.NewResponseError(resp)
	}
	return client.startCopyHandleResponse(resp)
}

// startCopyCreateRequest creates the StartCopy request.
func (client *fileClient) startCopyCreateRequest(ctx context.Context, copySource string, options *fileClientStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-copy-source"] = []string{copySource}
	if options != nil && options.FilePermission != nil {
		req.Raw().Header["x-ms-file-permission"] = []string{*options.FilePermission}
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header["x-ms-file-permission-key"] = []string{*options.FilePermissionKey}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FilePermissionCopyMode != nil {
		req.Raw().Header["x-ms-file-permission-copy-mode"] = []string{string(*copyFileSmbInfo.FilePermissionCopyMode)}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.IgnoreReadOnly != nil {
		req.Raw().Header["x-ms-file-copy-ignore-readonly"] = []string{strconv.FormatBool(*copyFileSmbInfo.IgnoreReadOnly)}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileAttributes != nil {
		req.Raw().Header["x-ms-file-attributes"] = []string{*copyFileSmbInfo.FileAttributes}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileCreationTime != nil {
		req.Raw().Header["x-ms-file-creation-time"] = []string{*copyFileSmbInfo.FileCreationTime}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileLastWriteTime != nil {
		req.Raw().Header["x-ms-file-last-write-time"] = []string{*copyFileSmbInfo.FileLastWriteTime}
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.SetArchiveAttribute != nil {
		req.Raw().Header["x-ms-file-copy-set-archive"] = []string{strconv.FormatBool(*copyFileSmbInfo.SetArchiveAttribute)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// startCopyHandleResponse handles the StartCopy response.
func (client *fileClient) startCopyHandleResponse(resp *http.Response) (fileClientStartCopyResponse, error) {
	result := fileClientStartCopyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientStartCopyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientStartCopyResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return result, nil
}

// UploadRange - Upload a range of bytes to a file.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// rangeParam - Specifies the range of bytes to be written. Both the start and end of the range must be specified. For an
// update operation, the range can be up to 4 MB in size. For a clear operation, the range can be
// up to the value of the file's full size. The File service accepts only a single byte range for the Range and 'x-ms-range'
// headers, and the byte range must be specified in the following format:
// bytes=startByte-endByte.
// fileRangeWrite - Specify one of the following options: - Update: Writes the bytes specified by the request body into the
// specified range. The Range and Content-Length headers must match to perform the update. - Clear:
// Clears the specified range and releases the space used in storage for that range. To clear a range, set the Content-Length
// header to zero, and set the Range header to a value that indicates the range
// to clear, up to maximum file size.
// contentLength - Specifies the number of bytes being transmitted in the request body. When the x-ms-write header is set
// to clear, the value of this header must be set to zero.
// options - fileClientUploadRangeOptions contains the optional parameters for the fileClient.UploadRange method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) UploadRange(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, options *fileClientUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientUploadRangeResponse, error) {
	req, err := client.uploadRangeCreateRequest(ctx, rangeParam, fileRangeWrite, contentLength, options, leaseAccessConditions)
	if err != nil {
		return fileClientUploadRangeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientUploadRangeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientUploadRangeResponse{}, runtime.NewResponseError(resp)
	}
	return client.uploadRangeHandleResponse(resp)
}

// uploadRangeCreateRequest creates the UploadRange request.
func (client *fileClient) uploadRangeCreateRequest(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, options *fileClientUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-range"] = []string{rangeParam}
	req.Raw().Header["x-ms-write"] = []string{string(fileRangeWrite)}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if options != nil && options.ContentMD5 != nil {
		req.Raw().Header["Content-MD5"] = []string{base64.StdEncoding.EncodeToString(options.ContentMD5)}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	if options != nil && options.Optionalbody != nil {
		return req, req.SetBody(options.Optionalbody, "application/octet-stream")
	}
	return req, nil
}

// uploadRangeHandleResponse handles the UploadRange response.
func (client *fileClient) uploadRangeHandleResponse(resp *http.Response) (fileClientUploadRangeResponse, error) {
	result := fileClientUploadRangeResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// UploadRangeFromURL - Upload a range of bytes to a file where the contents are read from a URL.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// rangeParam - Writes data to the specified byte range in the file.
// copySource - Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file to another file within
// the same storage account, you may use Shared Key to authenticate the source file. If you are
// copying a file from another storage account, or if you are copying a blob from the same storage account or another storage
// account, then you must authenticate the source file or blob using a shared
// access signature. If the source is a public blob, no authentication is required to perform the copy operation. A file in
// a share snapshot can also be specified as a copy source.
// contentLength - Specifies the number of bytes being transmitted in the request body. When the x-ms-write header is set
// to clear, the value of this header must be set to zero.
// options - fileClientUploadRangeFromURLOptions contains the optional parameters for the fileClient.UploadRangeFromURL method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the fileClient.UploadRangeFromURL
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) UploadRangeFromURL(ctx context.Context, rangeParam string, copySource string, contentLength int64, options *fileClientUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (fileClientUploadRangeFromURLResponse, error) {
	req, err := client.uploadRangeFromURLCreateRequest(ctx, rangeParam, copySource, contentLength, options, sourceModifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return fileClientUploadRangeFromURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientUploadRangeFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientUploadRangeFromURLResponse{}, runtime.NewResponseError(resp)
	}
	return client.uploadRangeFromURLHandleResponse(resp)
}

// uploadRangeFromURLCreateRequest creates the UploadRangeFromURL request.
func (client *fileClient) uploadRangeFromURLCreateRequest(ctx context.Context, rangeParam string, copySource string, contentLength int64, options *fileClientUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-range"] = []string{rangeParam}
	req.Raw().Header["x-ms-copy-source"] = []string{copySource}
	if options != nil && options.SourceRange != nil {
		req.Raw().Header["x-ms-source-range"] = []string{*options.SourceRange}
	}
	req.Raw().Header["x-ms-write"] = []string{"update"}
	req.Raw().Header["Content-Length"] = []string{strconv.FormatInt(contentLength, 10)}
	if options != nil && options.SourceContentCRC64 != nil {
		req.Raw().Header["x-ms-source-content-crc64"] = []string{base64.StdEncoding.EncodeToString(options.SourceContentCRC64)}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatchCRC64 != nil {
		req.Raw().Header["x-ms-source-if-match-crc64"] = []string{base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfMatchCRC64)}
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatchCRC64 != nil {
		req.Raw().Header["x-ms-source-if-none-match-crc64"] = []string{base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfNoneMatchCRC64)}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	if options != nil && options.CopySourceAuthorization != nil {
		req.Raw().Header["x-ms-copy-source-authorization"] = []string{*options.CopySourceAuthorization}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// uploadRangeFromURLHandleResponse handles the UploadRangeFromURL response.
func (client *fileClient) uploadRangeFromURLHandleResponse(resp *http.Response) (fileClientUploadRangeFromURLResponse, error) {
	result := fileClientUploadRangeFromURLResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	return result, nil
}
