//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type fileClient struct {
	endpoint string
	pl runtime.Pipeline
}

// newFileClient creates a new instance of fileClient with the specified values.
// endpoint - The URL of the service account, share, directory or file that is the target of the desired operation.
// pl - the pipeline used for sending requests and handling responses.
func newFileClient(endpoint string, pl runtime.Pipeline) *fileClient {
	client := &fileClient{
		endpoint: endpoint,
		pl: pl,
	}
	return client
}

// AbortCopy - Aborts a pending Copy File operation, and leaves a destination file with zero length and full metadata.
// If the operation fails it returns an *azcore.ResponseError type.
// copyID - The copy identifier provided in the x-ms-copy-id header of the original Copy File operation.
// fileClientAbortCopyOptions - fileClientAbortCopyOptions contains the optional parameters for the fileClient.AbortCopy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) AbortCopy(ctx context.Context, copyID string, fileClientAbortCopyOptions *fileClientAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientAbortCopyResponse, error) {
	req, err := client.abortCopyCreateRequest(ctx, copyID, fileClientAbortCopyOptions, leaseAccessConditions)
	if err != nil {
		return fileClientAbortCopyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientAbortCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return fileClientAbortCopyResponse{}, runtime.NewResponseError(resp)
	}
	return client.abortCopyHandleResponse(resp)
}

// abortCopyCreateRequest creates the AbortCopy request.
func (client *fileClient) abortCopyCreateRequest(ctx context.Context, copyID string, fileClientAbortCopyOptions *fileClientAbortCopyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "copy")
	reqQP.Set("copyid", copyID)
	if fileClientAbortCopyOptions != nil && fileClientAbortCopyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientAbortCopyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-copy-action", "abort")
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// abortCopyHandleResponse handles the AbortCopy response.
func (client *fileClient) abortCopyHandleResponse(resp *http.Response) (fileClientAbortCopyResponse, error) {
	result := fileClientAbortCopyResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAbortCopyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// AcquireLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// options - fileClientAcquireLeaseOptions contains the optional parameters for the fileClient.AcquireLease method.
func (client *fileClient) AcquireLease(ctx context.Context, options *fileClientAcquireLeaseOptions) (fileClientAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, options)
	if err != nil {
		return fileClientAcquireLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientAcquireLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *fileClient) acquireLeaseCreateRequest(ctx context.Context, options *fileClientAcquireLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Raw().Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *fileClient) acquireLeaseHandleResponse(resp *http.Response) (fileClientAcquireLeaseResponse, error) {
	result := fileClientAcquireLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// BreakLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientBreakLeaseOptions - fileClientBreakLeaseOptions contains the optional parameters for the fileClient.BreakLease
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) BreakLease(ctx context.Context, fileClientBreakLeaseOptions *fileClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, fileClientBreakLeaseOptions, leaseAccessConditions)
	if err != nil {
		return fileClientBreakLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientBreakLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *fileClient) breakLeaseCreateRequest(ctx context.Context, fileClientBreakLeaseOptions *fileClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if fileClientBreakLeaseOptions != nil && fileClientBreakLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientBreakLeaseOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "break")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if fileClientBreakLeaseOptions != nil && fileClientBreakLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *fileClientBreakLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *fileClient) breakLeaseHandleResponse(resp *http.Response) (fileClientBreakLeaseResponse, error) {
	result := fileClientBreakLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// ChangeLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// leaseID - Specifies the current lease ID on the resource.
// options - fileClientChangeLeaseOptions contains the optional parameters for the fileClient.ChangeLease method.
func (client *fileClient) ChangeLease(ctx context.Context, leaseID string, options *fileClientChangeLeaseOptions) (fileClientChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return fileClientChangeLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientChangeLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *fileClient) changeLeaseCreateRequest(ctx context.Context, leaseID string, options *fileClientChangeLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "change")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *fileClient) changeLeaseHandleResponse(resp *http.Response) (fileClientChangeLeaseResponse, error) {
	result := fileClientChangeLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Create - Creates a new file or replaces a file. Note it only initializes the file with no content.
// If the operation fails it returns an *azcore.ResponseError type.
// fileContentLength - Specifies the maximum size for the file, up to 4 TB.
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// fileClientCreateOptions - fileClientCreateOptions contains the optional parameters for the fileClient.Create method.
// FileHTTPHeaders - FileHTTPHeaders contains a group of parameters for the fileClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Create(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime string, fileLastWriteTime string, fileClientCreateOptions *fileClientCreateOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (fileClientCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, fileContentLength, fileAttributes, fileCreationTime, fileLastWriteTime, fileClientCreateOptions, fileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return fileClientCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *fileClient) createCreateRequest(ctx context.Context, fileContentLength int64, fileAttributes string, fileCreationTime string, fileLastWriteTime string, fileClientCreateOptions *fileClientCreateOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileClientCreateOptions != nil && fileClientCreateOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientCreateOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	req.Raw().Header.Set("x-ms-content-length", strconv.FormatInt(fileContentLength, 10))
	req.Raw().Header.Set("x-ms-type", "file")
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *fileHTTPHeaders.FileContentType)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *fileHTTPHeaders.FileContentEncoding)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *fileHTTPHeaders.FileContentLanguage)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileCacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *fileHTTPHeaders.FileCacheControl)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentMD5 != nil {
		req.Raw().Header.Set("x-ms-content-md5", base64.StdEncoding.EncodeToString(fileHTTPHeaders.FileContentMD5))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *fileHTTPHeaders.FileContentDisposition)
	}
	if fileClientCreateOptions != nil && fileClientCreateOptions.Metadata != nil {
		for k, v := range fileClientCreateOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if fileClientCreateOptions != nil && fileClientCreateOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileClientCreateOptions.FilePermission)
	}
	if fileClientCreateOptions != nil && fileClientCreateOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileClientCreateOptions.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime)
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *fileClient) createHandleResponse(resp *http.Response) (fileClientCreateResponse, error) {
	result := fileClientCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientCreateResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// Delete - removes the file from the storage account.
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientDeleteOptions - fileClientDeleteOptions contains the optional parameters for the fileClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Delete(ctx context.Context, fileClientDeleteOptions *fileClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, fileClientDeleteOptions, leaseAccessConditions)
	if err != nil {
		return fileClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *fileClient) deleteCreateRequest(ctx context.Context, fileClientDeleteOptions *fileClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileClientDeleteOptions != nil && fileClientDeleteOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientDeleteOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *fileClient) deleteHandleResponse(resp *http.Response) (fileClientDeleteResponse, error) {
	result := fileClientDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Download - Reads or downloads a file from the system, including its metadata and properties.
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientDownloadOptions - fileClientDownloadOptions contains the optional parameters for the fileClient.Download method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) Download(ctx context.Context, fileClientDownloadOptions *fileClientDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientDownloadResponse, error) {
	req, err := client.downloadCreateRequest(ctx, fileClientDownloadOptions, leaseAccessConditions)
	if err != nil {
		return fileClientDownloadResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientDownloadResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusPartialContent) {
		return fileClientDownloadResponse{}, runtime.NewResponseError(resp)
	}
	return client.downloadHandleResponse(resp)
}

// downloadCreateRequest creates the Download request.
func (client *fileClient) downloadCreateRequest(ctx context.Context, fileClientDownloadOptions *fileClientDownloadOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileClientDownloadOptions != nil && fileClientDownloadOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientDownloadOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	runtime.SkipBodyDownload(req)
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if fileClientDownloadOptions != nil && fileClientDownloadOptions.Range != nil {
		req.Raw().Header.Set("x-ms-range", *fileClientDownloadOptions.Range)
	}
	if fileClientDownloadOptions != nil && fileClientDownloadOptions.RangeGetContentMD5 != nil {
		req.Raw().Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*fileClientDownloadOptions.RangeGetContentMD5))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *fileClient) downloadHandleResponse(resp *http.Response) (fileClientDownloadResponse, error) {
	result := fileClientDownloadResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-content-md5"); val != "" {
		fileContentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.FileContentMD5 = fileContentMD5
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientDownloadResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// ForceCloseHandles - Closes all handles open for given file
// If the operation fails it returns an *azcore.ResponseError type.
// handleID - Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is a wildcard that specifies
// all handles.
// options - fileClientForceCloseHandlesOptions contains the optional parameters for the fileClient.ForceCloseHandles method.
func (client *fileClient) ForceCloseHandles(ctx context.Context, handleID string, options *fileClientForceCloseHandlesOptions) (fileClientForceCloseHandlesResponse, error) {
	req, err := client.forceCloseHandlesCreateRequest(ctx, handleID, options)
	if err != nil {
		return fileClientForceCloseHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientForceCloseHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientForceCloseHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.forceCloseHandlesHandleResponse(resp)
}

// forceCloseHandlesCreateRequest creates the ForceCloseHandles request.
func (client *fileClient) forceCloseHandlesCreateRequest(ctx context.Context, handleID string, options *fileClientForceCloseHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "forceclosehandles")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-handle-id", handleID)
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// forceCloseHandlesHandleResponse handles the ForceCloseHandles response.
func (client *fileClient) forceCloseHandlesHandleResponse(resp *http.Response) (fileClientForceCloseHandlesResponse, error) {
	result := fileClientForceCloseHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-marker"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-number-of-handles-closed"); val != "" {
		numberOfHandlesClosed32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesClosed := int32(numberOfHandlesClosed32)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesClosed = &numberOfHandlesClosed
	}
	if val := resp.Header.Get("x-ms-number-of-handles-failed"); val != "" {
		numberOfHandlesFailedToClose32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesFailedToClose := int32(numberOfHandlesFailedToClose32)
		if err != nil {
			return fileClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesFailedToClose = &numberOfHandlesFailedToClose
	}
	return result, nil
}

// GetProperties - Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It does
// not return the content of the file.
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientGetPropertiesOptions - fileClientGetPropertiesOptions contains the optional parameters for the fileClient.GetProperties
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) GetProperties(ctx context.Context, fileClientGetPropertiesOptions *fileClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, fileClientGetPropertiesOptions, leaseAccessConditions)
	if err != nil {
		return fileClientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *fileClient) getPropertiesCreateRequest(ctx context.Context, fileClientGetPropertiesOptions *fileClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodHead, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileClientGetPropertiesOptions != nil && fileClientGetPropertiesOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *fileClientGetPropertiesOptions.Sharesnapshot)
	}
	if fileClientGetPropertiesOptions != nil && fileClientGetPropertiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientGetPropertiesOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *fileClient) getPropertiesHandleResponse(resp *http.Response) (fileClientGetPropertiesResponse, error) {
	result := fileClientGetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-type"); val != "" {
		result.FileType = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetPropertiesResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	return result, nil
}

// GetRangeList - Returns the list of valid ranges for a file.
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientGetRangeListOptions - fileClientGetRangeListOptions contains the optional parameters for the fileClient.GetRangeList
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) GetRangeList(ctx context.Context, fileClientGetRangeListOptions *fileClientGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientGetRangeListResponse, error) {
	req, err := client.getRangeListCreateRequest(ctx, fileClientGetRangeListOptions, leaseAccessConditions)
	if err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientGetRangeListResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRangeListHandleResponse(resp)
}

// getRangeListCreateRequest creates the GetRangeList request.
func (client *fileClient) getRangeListCreateRequest(ctx context.Context, fileClientGetRangeListOptions *fileClientGetRangeListOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "rangelist")
	if fileClientGetRangeListOptions != nil && fileClientGetRangeListOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *fileClientGetRangeListOptions.Sharesnapshot)
	}
	if fileClientGetRangeListOptions != nil && fileClientGetRangeListOptions.Prevsharesnapshot != nil {
		reqQP.Set("prevsharesnapshot", *fileClientGetRangeListOptions.Prevsharesnapshot)
	}
	if fileClientGetRangeListOptions != nil && fileClientGetRangeListOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientGetRangeListOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if fileClientGetRangeListOptions != nil && fileClientGetRangeListOptions.Range != nil {
		req.Raw().Header.Set("x-ms-range", *fileClientGetRangeListOptions.Range)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getRangeListHandleResponse handles the GetRangeList response.
func (client *fileClient) getRangeListHandleResponse(resp *http.Response) (fileClientGetRangeListResponse, error) {
	result := fileClientGetRangeListResponse{RawResponse: resp}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-content-length"); val != "" {
		fileContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.FileContentLength = &fileContentLength
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientGetRangeListResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ShareFileRangeList); err != nil {
		return fileClientGetRangeListResponse{}, err
	}
	return result, nil
}

// ListHandles - Lists handles for file
// If the operation fails it returns an *azcore.ResponseError type.
// options - fileClientListHandlesOptions contains the optional parameters for the fileClient.ListHandles method.
func (client *fileClient) ListHandles(ctx context.Context, options *fileClientListHandlesOptions) (fileClientListHandlesResponse, error) {
	req, err := client.listHandlesCreateRequest(ctx, options)
	if err != nil {
		return fileClientListHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientListHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientListHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHandlesHandleResponse(resp)
}

// listHandlesCreateRequest creates the ListHandles request.
func (client *fileClient) listHandlesCreateRequest(ctx context.Context, options *fileClientListHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "listhandles")
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// listHandlesHandleResponse handles the ListHandles response.
func (client *fileClient) listHandlesHandleResponse(resp *http.Response) (fileClientListHandlesResponse, error) {
	result := fileClientListHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientListHandlesResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListHandlesResponse); err != nil {
		return fileClientListHandlesResponse{}, err
	}
	return result, nil
}

// ReleaseLease - [Update] The Lease File operation establishes and manages a lock on a file for write and delete operations
// If the operation fails it returns an *azcore.ResponseError type.
// leaseID - Specifies the current lease ID on the resource.
// options - fileClientReleaseLeaseOptions contains the optional parameters for the fileClient.ReleaseLease method.
func (client *fileClient) ReleaseLease(ctx context.Context, leaseID string, options *fileClientReleaseLeaseOptions) (fileClientReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return fileClientReleaseLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientReleaseLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *fileClient) releaseLeaseCreateRequest(ctx context.Context, leaseID string, options *fileClientReleaseLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "release")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *fileClient) releaseLeaseHandleResponse(resp *http.Response) (fileClientReleaseLeaseResponse, error) {
	result := fileClientReleaseLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetHTTPHeaders - Sets HTTP headers on the file.
// If the operation fails it returns an *azcore.ResponseError type.
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// fileClientSetHTTPHeadersOptions - fileClientSetHTTPHeadersOptions contains the optional parameters for the fileClient.SetHTTPHeaders
// method.
// FileHTTPHeaders - FileHTTPHeaders contains a group of parameters for the fileClient.Create method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) SetHTTPHeaders(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, fileClientSetHTTPHeadersOptions *fileClientSetHTTPHeadersOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (fileClientSetHTTPHeadersResponse, error) {
	req, err := client.setHTTPHeadersCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, fileClientSetHTTPHeadersOptions, fileHTTPHeaders, leaseAccessConditions)
	if err != nil {
		return fileClientSetHTTPHeadersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientSetHTTPHeadersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientSetHTTPHeadersResponse{}, runtime.NewResponseError(resp)
	}
	return client.setHTTPHeadersHandleResponse(resp)
}

// setHTTPHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *fileClient) setHTTPHeadersCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, fileClientSetHTTPHeadersOptions *fileClientSetHTTPHeadersOptions, fileHTTPHeaders *FileHTTPHeaders, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "properties")
	if fileClientSetHTTPHeadersOptions != nil && fileClientSetHTTPHeadersOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientSetHTTPHeadersOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if fileClientSetHTTPHeadersOptions != nil && fileClientSetHTTPHeadersOptions.FileContentLength != nil {
		req.Raw().Header.Set("x-ms-content-length", strconv.FormatInt(*fileClientSetHTTPHeadersOptions.FileContentLength, 10))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentType != nil {
		req.Raw().Header.Set("x-ms-content-type", *fileHTTPHeaders.FileContentType)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentEncoding != nil {
		req.Raw().Header.Set("x-ms-content-encoding", *fileHTTPHeaders.FileContentEncoding)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentLanguage != nil {
		req.Raw().Header.Set("x-ms-content-language", *fileHTTPHeaders.FileContentLanguage)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileCacheControl != nil {
		req.Raw().Header.Set("x-ms-cache-control", *fileHTTPHeaders.FileCacheControl)
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentMD5 != nil {
		req.Raw().Header.Set("x-ms-content-md5", base64.StdEncoding.EncodeToString(fileHTTPHeaders.FileContentMD5))
	}
	if fileHTTPHeaders != nil && fileHTTPHeaders.FileContentDisposition != nil {
		req.Raw().Header.Set("x-ms-content-disposition", *fileHTTPHeaders.FileContentDisposition)
	}
	if fileClientSetHTTPHeadersOptions != nil && fileClientSetHTTPHeadersOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileClientSetHTTPHeadersOptions.FilePermission)
	}
	if fileClientSetHTTPHeadersOptions != nil && fileClientSetHTTPHeadersOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileClientSetHTTPHeadersOptions.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime)
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime)
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setHTTPHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *fileClient) setHTTPHeadersHandleResponse(resp *http.Response) (fileClientSetHTTPHeadersResponse, error) {
	result := fileClientSetHTTPHeadersResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetHTTPHeadersResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// SetMetadata - Updates user-defined metadata for the specified file.
// If the operation fails it returns an *azcore.ResponseError type.
// fileClientSetMetadataOptions - fileClientSetMetadataOptions contains the optional parameters for the fileClient.SetMetadata
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) SetMetadata(ctx context.Context, fileClientSetMetadataOptions *fileClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, fileClientSetMetadataOptions, leaseAccessConditions)
	if err != nil {
		return fileClientSetMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return fileClientSetMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *fileClient) setMetadataCreateRequest(ctx context.Context, fileClientSetMetadataOptions *fileClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "metadata")
	if fileClientSetMetadataOptions != nil && fileClientSetMetadataOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientSetMetadataOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if fileClientSetMetadataOptions != nil && fileClientSetMetadataOptions.Metadata != nil {
		for k, v := range fileClientSetMetadataOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *fileClient) setMetadataHandleResponse(resp *http.Response) (fileClientSetMetadataResponse, error) {
	result := fileClientSetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	return result, nil
}

// StartCopy - Copies a blob or file to a destination file within the storage account.
// If the operation fails it returns an *azcore.ResponseError type.
// copySource - Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file to another file within
// the same storage account, you may use Shared Key to authenticate the source file. If you are
// copying a file from another storage account, or if you are copying a blob from the same storage account or another storage
// account, then you must authenticate the source file or blob using a shared
// access signature. If the source is a public blob, no authentication is required to perform the copy operation. A file in
// a share snapshot can also be specified as a copy source.
// fileClientStartCopyOptions - fileClientStartCopyOptions contains the optional parameters for the fileClient.StartCopy method.
// CopyFileSmbInfo - CopyFileSmbInfo contains a group of parameters for the fileClient.StartCopy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) StartCopy(ctx context.Context, copySource string, fileClientStartCopyOptions *fileClientStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (fileClientStartCopyResponse, error) {
	req, err := client.startCopyCreateRequest(ctx, copySource, fileClientStartCopyOptions, copyFileSmbInfo, leaseAccessConditions)
	if err != nil {
		return fileClientStartCopyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientStartCopyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return fileClientStartCopyResponse{}, runtime.NewResponseError(resp)
	}
	return client.startCopyHandleResponse(resp)
}

// startCopyCreateRequest creates the StartCopy request.
func (client *fileClient) startCopyCreateRequest(ctx context.Context, copySource string, fileClientStartCopyOptions *fileClientStartCopyOptions, copyFileSmbInfo *CopyFileSmbInfo, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if fileClientStartCopyOptions != nil && fileClientStartCopyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientStartCopyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if fileClientStartCopyOptions != nil && fileClientStartCopyOptions.Metadata != nil {
		for k, v := range fileClientStartCopyOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if fileClientStartCopyOptions != nil && fileClientStartCopyOptions.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *fileClientStartCopyOptions.FilePermission)
	}
	if fileClientStartCopyOptions != nil && fileClientStartCopyOptions.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *fileClientStartCopyOptions.FilePermissionKey)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FilePermissionCopyMode != nil {
		req.Raw().Header.Set("x-ms-file-permission-copy-mode", string(*copyFileSmbInfo.FilePermissionCopyMode))
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.IgnoreReadOnly != nil {
		req.Raw().Header.Set("x-ms-file-copy-ignore-readonly", strconv.FormatBool(*copyFileSmbInfo.IgnoreReadOnly))
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileAttributes != nil {
		req.Raw().Header.Set("x-ms-file-attributes", *copyFileSmbInfo.FileAttributes)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileCreationTime != nil {
		req.Raw().Header.Set("x-ms-file-creation-time", *copyFileSmbInfo.FileCreationTime)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.FileLastWriteTime != nil {
		req.Raw().Header.Set("x-ms-file-last-write-time", *copyFileSmbInfo.FileLastWriteTime)
	}
	if copyFileSmbInfo != nil && copyFileSmbInfo.SetArchiveAttribute != nil {
		req.Raw().Header.Set("x-ms-file-copy-set-archive", strconv.FormatBool(*copyFileSmbInfo.SetArchiveAttribute))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// startCopyHandleResponse handles the StartCopy response.
func (client *fileClient) startCopyHandleResponse(resp *http.Response) (fileClientStartCopyResponse, error) {
	result := fileClientStartCopyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientStartCopyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientStartCopyResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return result, nil
}

// UploadRange - Upload a range of bytes to a file.
// If the operation fails it returns an *azcore.ResponseError type.
// rangeParam - Specifies the range of bytes to be written. Both the start and end of the range must be specified. For an
// update operation, the range can be up to 4 MB in size. For a clear operation, the range can be
// up to the value of the file's full size. The File service accepts only a single byte range for the Range and 'x-ms-range'
// headers, and the byte range must be specified in the following format:
// bytes=startByte-endByte.
// fileRangeWrite - Specify one of the following options: - Update: Writes the bytes specified by the request body into the
// specified range. The Range and Content-Length headers must match to perform the update. - Clear:
// Clears the specified range and releases the space used in storage for that range. To clear a range, set the Content-Length
// header to zero, and set the Range header to a value that indicates the range
// to clear, up to maximum file size.
// contentLength - Specifies the number of bytes being transmitted in the request body. When the x-ms-write header is set
// to clear, the value of this header must be set to zero.
// fileClientUploadRangeOptions - fileClientUploadRangeOptions contains the optional parameters for the fileClient.UploadRange
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) UploadRange(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, fileClientUploadRangeOptions *fileClientUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (fileClientUploadRangeResponse, error) {
	req, err := client.uploadRangeCreateRequest(ctx, rangeParam, fileRangeWrite, contentLength, fileClientUploadRangeOptions, leaseAccessConditions)
	if err != nil {
		return fileClientUploadRangeResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientUploadRangeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientUploadRangeResponse{}, runtime.NewResponseError(resp)
	}
	return client.uploadRangeHandleResponse(resp)
}

// uploadRangeCreateRequest creates the UploadRange request.
func (client *fileClient) uploadRangeCreateRequest(ctx context.Context, rangeParam string, fileRangeWrite FileRangeWriteType, contentLength int64, fileClientUploadRangeOptions *fileClientUploadRangeOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if fileClientUploadRangeOptions != nil && fileClientUploadRangeOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientUploadRangeOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-range", rangeParam)
	req.Raw().Header.Set("x-ms-write", string(fileRangeWrite))
	req.Raw().Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if fileClientUploadRangeOptions != nil && fileClientUploadRangeOptions.ContentMD5 != nil {
		req.Raw().Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(fileClientUploadRangeOptions.ContentMD5))
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	if fileClientUploadRangeOptions != nil && fileClientUploadRangeOptions.Optionalbody != nil {
	return req, req.SetBody(fileClientUploadRangeOptions.Optionalbody, "application/octet-stream")
	}
	return req, nil
}

// uploadRangeHandleResponse handles the UploadRange response.
func (client *fileClient) uploadRangeHandleResponse(resp *http.Response) (fileClientUploadRangeResponse, error) {
	result := fileClientUploadRangeResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientUploadRangeResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// UploadRangeFromURL - Upload a range of bytes to a file where the contents are read from a URL.
// If the operation fails it returns an *azcore.ResponseError type.
// rangeParam - Writes data to the specified byte range in the file.
// copySource - Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file to another file within
// the same storage account, you may use Shared Key to authenticate the source file. If you are
// copying a file from another storage account, or if you are copying a blob from the same storage account or another storage
// account, then you must authenticate the source file or blob using a shared
// access signature. If the source is a public blob, no authentication is required to perform the copy operation. A file in
// a share snapshot can also be specified as a copy source.
// contentLength - Specifies the number of bytes being transmitted in the request body. When the x-ms-write header is set
// to clear, the value of this header must be set to zero.
// fileClientUploadRangeFromURLOptions - fileClientUploadRangeFromURLOptions contains the optional parameters for the fileClient.UploadRangeFromURL
// method.
// SourceModifiedAccessConditions - SourceModifiedAccessConditions contains a group of parameters for the fileClient.UploadRangeFromURL
// method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *fileClient) UploadRangeFromURL(ctx context.Context, rangeParam string, copySource string, contentLength int64, fileClientUploadRangeFromURLOptions *fileClientUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (fileClientUploadRangeFromURLResponse, error) {
	req, err := client.uploadRangeFromURLCreateRequest(ctx, rangeParam, copySource, contentLength, fileClientUploadRangeFromURLOptions, sourceModifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return fileClientUploadRangeFromURLResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return fileClientUploadRangeFromURLResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return fileClientUploadRangeFromURLResponse{}, runtime.NewResponseError(resp)
	}
	return client.uploadRangeFromURLHandleResponse(resp)
}

// uploadRangeFromURLCreateRequest creates the UploadRangeFromURL request.
func (client *fileClient) uploadRangeFromURLCreateRequest(ctx context.Context, rangeParam string, copySource string, contentLength int64, fileClientUploadRangeFromURLOptions *fileClientUploadRangeFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "range")
	if fileClientUploadRangeFromURLOptions != nil && fileClientUploadRangeFromURLOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*fileClientUploadRangeFromURLOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-range", rangeParam)
	req.Raw().Header.Set("x-ms-copy-source", copySource)
	if fileClientUploadRangeFromURLOptions != nil && fileClientUploadRangeFromURLOptions.SourceRange != nil {
		req.Raw().Header.Set("x-ms-source-range", *fileClientUploadRangeFromURLOptions.SourceRange)
	}
	req.Raw().Header.Set("x-ms-write", "update")
	req.Raw().Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if fileClientUploadRangeFromURLOptions != nil && fileClientUploadRangeFromURLOptions.SourceContentCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-content-crc64", base64.StdEncoding.EncodeToString(fileClientUploadRangeFromURLOptions.SourceContentCRC64))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatchCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-if-match-crc64", base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfMatchCRC64))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatchCRC64 != nil {
		req.Raw().Header.Set("x-ms-source-if-none-match-crc64", base64.StdEncoding.EncodeToString(sourceModifiedAccessConditions.SourceIfNoneMatchCRC64))
	}
	req.Raw().Header.Set("x-ms-version", "2020-10-02")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	if fileClientUploadRangeFromURLOptions != nil && fileClientUploadRangeFromURLOptions.CopySourceAuthorization != nil {
		req.Raw().Header.Set("x-ms-copy-source-authorization", *fileClientUploadRangeFromURLOptions.CopySourceAuthorization)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// uploadRangeFromURLHandleResponse handles the UploadRangeFromURL response.
func (client *fileClient) uploadRangeFromURLHandleResponse(resp *http.Response) (fileClientUploadRangeFromURLResponse, error) {
	result := fileClientUploadRangeFromURLResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		xMSContentCRC64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.XMSContentCRC64 = xMSContentCRC64
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMD5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return fileClientUploadRangeFromURLResponse{}, err
		}
		result.ContentMD5 = contentMD5
	}
	return result, nil
}

