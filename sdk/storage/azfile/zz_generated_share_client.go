//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/xml"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type shareClient struct {
	con *connection
}

// Create - Creates a new share under the specified account. If the share with the same name already exists, the operation fails.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Create(ctx context.Context, options *ShareCreateOptions) (ShareCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, options)
	if err != nil {
		return ShareCreateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreateResponse{}, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *shareClient) createCreateRequest(ctx context.Context, options *ShareCreateOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if options != nil && options.Quota != nil {
		req.Raw().Header.Set("x-ms-share-quota", strconv.FormatInt(int64(*options.Quota), 10))
	}
	if options != nil && options.AccessTier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*options.AccessTier))
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *shareClient) createHandleResponse(resp *http.Response) (ShareCreateResponse, error) {
	result := ShareCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// createHandleError handles the Create error response.
func (client *shareClient) createHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreatePermission - Create a permission (a security descriptor).
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) CreatePermission(ctx context.Context, sharePermission SharePermission, options *ShareCreatePermissionOptions) (ShareCreatePermissionResponse, error) {
	req, err := client.createPermissionCreateRequest(ctx, sharePermission, options)
	if err != nil {
		return ShareCreatePermissionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreatePermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreatePermissionResponse{}, client.createPermissionHandleError(resp)
	}
	return client.createPermissionHandleResponse(resp)
}

// createPermissionCreateRequest creates the CreatePermission request.
func (client *shareClient) createPermissionCreateRequest(ctx context.Context, sharePermission SharePermission, options *ShareCreatePermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, runtime.MarshalAsJSON(req, sharePermission)
}

// createPermissionHandleResponse handles the CreatePermission response.
func (client *shareClient) createPermissionHandleResponse(resp *http.Response) (ShareCreatePermissionResponse, error) {
	result := ShareCreatePermissionResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreatePermissionResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	return result, nil
}

// createPermissionHandleError handles the CreatePermission error response.
func (client *shareClient) createPermissionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateSnapshot - Creates a read-only snapshot of a share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) CreateSnapshot(ctx context.Context, options *ShareCreateSnapshotOptions) (ShareCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(ctx, options)
	if err != nil {
		return ShareCreateSnapshotResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreateSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreateSnapshotResponse{}, client.createSnapshotHandleError(resp)
	}
	return client.createSnapshotHandleResponse(resp)
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *shareClient) createSnapshotCreateRequest(ctx context.Context, options *ShareCreateSnapshotOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "snapshot")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *shareClient) createSnapshotHandleResponse(resp *http.Response) (ShareCreateSnapshotResponse, error) {
	result := ShareCreateSnapshotResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateSnapshotResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateSnapshotResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// createSnapshotHandleError handles the CreateSnapshot error response.
func (client *shareClient) createSnapshotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Operation marks the specified share or share snapshot for deletion. The share or share snapshot and any files contained within it are later
// deleted during garbage collection.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Delete(ctx context.Context, options *ShareDeleteOptions) (ShareDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, options)
	if err != nil {
		return ShareDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return ShareDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *shareClient) deleteCreateRequest(ctx context.Context, options *ShareDeleteOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.DeleteSnapshots != nil {
		req.Raw().Header.Set("x-ms-delete-snapshots", "include")
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *shareClient) deleteHandleResponse(resp *http.Response) (ShareDeleteResponse, error) {
	result := ShareDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *shareClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAccessPolicy - Returns information about stored access policies specified on the share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetAccessPolicy(ctx context.Context, options *ShareGetAccessPolicyOptions) (ShareGetAccessPolicyResponse, error) {
	req, err := client.getAccessPolicyCreateRequest(ctx, options)
	if err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetAccessPolicyResponse{}, client.getAccessPolicyHandleError(resp)
	}
	return client.getAccessPolicyHandleResponse(resp)
}

// getAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *shareClient) getAccessPolicyCreateRequest(ctx context.Context, options *ShareGetAccessPolicyOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *shareClient) getAccessPolicyHandleResponse(resp *http.Response) (ShareGetAccessPolicyResponse, error) {
	result := ShareGetAccessPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	return result, nil
}

// getAccessPolicyHandleError handles the GetAccessPolicy error response.
func (client *shareClient) getAccessPolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPermission - Returns the permission (security descriptor) for a given key
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetPermission(ctx context.Context, filePermissionKey string, options *ShareGetPermissionOptions) (ShareGetPermissionResponse, error) {
	req, err := client.getPermissionCreateRequest(ctx, filePermissionKey, options)
	if err != nil {
		return ShareGetPermissionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetPermissionResponse{}, client.getPermissionHandleError(resp)
	}
	return client.getPermissionHandleResponse(resp)
}

// getPermissionCreateRequest creates the GetPermission request.
func (client *shareClient) getPermissionCreateRequest(ctx context.Context, filePermissionKey string, options *ShareGetPermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-file-permission-key", filePermissionKey)
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPermissionHandleResponse handles the GetPermission response.
func (client *shareClient) getPermissionHandleResponse(resp *http.Response) (ShareGetPermissionResponse, error) {
	result := ShareGetPermissionResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPermissionResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SharePermission); err != nil {
		return ShareGetPermissionResponse{}, err
	}
	return result, nil
}

// getPermissionHandleError handles the GetPermission error response.
func (client *shareClient) getPermissionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetProperties - Returns all user-defined metadata and system properties for the specified share or share snapshot. The data returned does not include
// the share's list of files.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetProperties(ctx context.Context, options *ShareGetPropertiesOptions) (ShareGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, options)
	if err != nil {
		return ShareGetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetPropertiesResponse{}, client.getPropertiesHandleError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *shareClient) getPropertiesCreateRequest(ctx context.Context, options *ShareGetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *shareClient) getPropertiesHandleResponse(resp *http.Response) (ShareGetPropertiesResponse, error) {
	result := ShareGetPropertiesResponse{RawResponse: resp}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-share-quota"); val != "" {
		quota32, err := strconv.ParseInt(val, 10, 32)
		quota := int32(quota32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.Quota = &quota
	}
	if val := resp.Header.Get("x-ms-share-provisioned-iops"); val != "" {
		provisionedIops32, err := strconv.ParseInt(val, 10, 32)
		provisionedIops := int32(provisionedIops32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedIops = &provisionedIops
	}
	if val := resp.Header.Get("x-ms-share-provisioned-ingress-mbps"); val != "" {
		provisionedIngressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedIngressMBps := int32(provisionedIngressMBps32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedIngressMBps = &provisionedIngressMBps
	}
	if val := resp.Header.Get("x-ms-share-provisioned-egress-mbps"); val != "" {
		provisionedEgressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedEgressMBps := int32(provisionedEgressMBps32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedEgressMBps = &provisionedEgressMBps
	}
	if val := resp.Header.Get("x-ms-share-next-allowed-quota-downgrade-time"); val != "" {
		nextAllowedQuotaDowngradeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.NextAllowedQuotaDowngradeTime = &nextAllowedQuotaDowngradeTime
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	if val := resp.Header.Get("x-ms-access-tier-transition-state"); val != "" {
		result.AccessTierTransitionState = &val
	}
	return result, nil
}

// getPropertiesHandleError handles the GetProperties error response.
func (client *shareClient) getPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStatistics - Retrieves statistics related to the share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetStatistics(ctx context.Context, options *ShareGetStatisticsOptions) (ShareGetStatisticsResponse, error) {
	req, err := client.getStatisticsCreateRequest(ctx, options)
	if err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetStatisticsResponse{}, client.getStatisticsHandleError(resp)
	}
	return client.getStatisticsHandleResponse(resp)
}

// getStatisticsCreateRequest creates the GetStatistics request.
func (client *shareClient) getStatisticsCreateRequest(ctx context.Context, options *ShareGetStatisticsOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "stats")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getStatisticsHandleResponse handles the GetStatistics response.
func (client *shareClient) getStatisticsHandleResponse(resp *http.Response) (ShareGetStatisticsResponse, error) {
	result := ShareGetStatisticsResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetStatisticsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetStatisticsResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ShareStats); err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	return result, nil
}

// getStatisticsHandleError handles the GetStatistics error response.
func (client *shareClient) getStatisticsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Restore - Restores a previously deleted Share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Restore(ctx context.Context, options *ShareRestoreOptions) (ShareRestoreResponse, error) {
	req, err := client.restoreCreateRequest(ctx, options)
	if err != nil {
		return ShareRestoreResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareRestoreResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareRestoreResponse{}, client.restoreHandleError(resp)
	}
	return client.restoreHandleResponse(resp)
}

// restoreCreateRequest creates the Restore request.
func (client *shareClient) restoreCreateRequest(ctx context.Context, options *ShareRestoreOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	if options != nil && options.DeletedShareName != nil {
		req.Raw().Header.Set("x-ms-deleted-share-name", *options.DeletedShareName)
	}
	if options != nil && options.DeletedShareVersion != nil {
		req.Raw().Header.Set("x-ms-deleted-share-version", *options.DeletedShareVersion)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// restoreHandleResponse handles the Restore response.
func (client *shareClient) restoreHandleResponse(resp *http.Response) (ShareRestoreResponse, error) {
	result := ShareRestoreResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRestoreResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRestoreResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// restoreHandleError handles the Restore error response.
func (client *shareClient) restoreHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetAccessPolicy - Sets a stored access policy for use with shared access signatures.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetAccessPolicy(ctx context.Context, options *ShareSetAccessPolicyOptions) (ShareSetAccessPolicyResponse, error) {
	req, err := client.setAccessPolicyCreateRequest(ctx, options)
	if err != nil {
		return ShareSetAccessPolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetAccessPolicyResponse{}, client.setAccessPolicyHandleError(resp)
	}
	return client.setAccessPolicyHandleResponse(resp)
}

// setAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *shareClient) setAccessPolicyCreateRequest(ctx context.Context, options *ShareSetAccessPolicyOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	type wrapper struct {
		XMLName  xml.Name             `xml:"SignedIdentifiers"`
		ShareACL *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	if options != nil && options.ShareACL != nil {
		return req, runtime.MarshalAsXML(req, wrapper{ShareACL: &options.ShareACL})
	}
	return req, nil
}

// setAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *shareClient) setAccessPolicyHandleResponse(resp *http.Response) (ShareSetAccessPolicyResponse, error) {
	result := ShareSetAccessPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setAccessPolicyHandleError handles the SetAccessPolicy error response.
func (client *shareClient) setAccessPolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetMetadata - Sets one or more user-defined name-value pairs for the specified share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetMetadata(ctx context.Context, options *ShareSetMetadataOptions) (ShareSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, options)
	if err != nil {
		return ShareSetMetadataResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetMetadataResponse{}, client.setMetadataHandleError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *shareClient) setMetadataCreateRequest(ctx context.Context, options *ShareSetMetadataOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *shareClient) setMetadataHandleResponse(resp *http.Response) (ShareSetMetadataResponse, error) {
	result := ShareSetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setMetadataHandleError handles the SetMetadata error response.
func (client *shareClient) setMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetProperties - Sets properties for the specified share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetProperties(ctx context.Context, options *ShareSetPropertiesOptions) (ShareSetPropertiesResponse, error) {
	req, err := client.setPropertiesCreateRequest(ctx, options)
	if err != nil {
		return ShareSetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetPropertiesResponse{}, client.setPropertiesHandleError(resp)
	}
	return client.setPropertiesHandleResponse(resp)
}

// setPropertiesCreateRequest creates the SetProperties request.
func (client *shareClient) setPropertiesCreateRequest(ctx context.Context, options *ShareSetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.Quota != nil {
		req.Raw().Header.Set("x-ms-share-quota", strconv.FormatInt(int64(*options.Quota), 10))
	}
	if options != nil && options.AccessTier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*options.AccessTier))
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setPropertiesHandleResponse handles the SetProperties response.
func (client *shareClient) setPropertiesHandleResponse(resp *http.Response) (ShareSetPropertiesResponse, error) {
	result := ShareSetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setPropertiesHandleError handles the SetProperties error response.
func (client *shareClient) setPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
