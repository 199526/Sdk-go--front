//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/xml"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type shareClient struct {
	con *connection
}

// AcquireLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and delete share operations.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) AcquireLease(ctx context.Context, options *ShareAcquireLeaseOptions) (ShareAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, options)
	if err != nil {
		return ShareAcquireLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareAcquireLeaseResponse{}, client.acquireLeaseHandleError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *shareClient) acquireLeaseCreateRequest(ctx context.Context, options *ShareAcquireLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Raw().Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *shareClient) acquireLeaseHandleResponse(resp *http.Response) (ShareAcquireLeaseResponse, error) {
	result := ShareAcquireLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// acquireLeaseHandleError handles the AcquireLease error response.
func (client *shareClient) acquireLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BreakLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and delete share operations.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) BreakLease(ctx context.Context, shareBreakLeaseOptions *ShareBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (ShareBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, shareBreakLeaseOptions, leaseAccessConditions)
	if err != nil {
		return ShareBreakLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return ShareBreakLeaseResponse{}, client.breakLeaseHandleError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *shareClient) breakLeaseCreateRequest(ctx context.Context, shareBreakLeaseOptions *ShareBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if shareBreakLeaseOptions != nil && shareBreakLeaseOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareBreakLeaseOptions.Timeout), 10))
	}
	if shareBreakLeaseOptions != nil && shareBreakLeaseOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *shareBreakLeaseOptions.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "break")
	if shareBreakLeaseOptions != nil && shareBreakLeaseOptions.BreakPeriod != nil {
		req.Raw().Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*shareBreakLeaseOptions.BreakPeriod), 10))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if shareBreakLeaseOptions != nil && shareBreakLeaseOptions.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *shareBreakLeaseOptions.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *shareClient) breakLeaseHandleResponse(resp *http.Response) (ShareBreakLeaseResponse, error) {
	result := ShareBreakLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return ShareBreakLeaseResponse{}, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// breakLeaseHandleError handles the BreakLease error response.
func (client *shareClient) breakLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ChangeLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and delete share operations.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) ChangeLease(ctx context.Context, leaseID string, options *ShareChangeLeaseOptions) (ShareChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return ShareChangeLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareChangeLeaseResponse{}, client.changeLeaseHandleError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *shareClient) changeLeaseCreateRequest(ctx context.Context, leaseID string, options *ShareChangeLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "change")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseID)
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *shareClient) changeLeaseHandleResponse(resp *http.Response) (ShareChangeLeaseResponse, error) {
	result := ShareChangeLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// changeLeaseHandleError handles the ChangeLease error response.
func (client *shareClient) changeLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Create - Creates a new share under the specified account. If the share with the same name already exists, the operation fails.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Create(ctx context.Context, options *ShareCreateOptions) (ShareCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, options)
	if err != nil {
		return ShareCreateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreateResponse{}, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *shareClient) createCreateRequest(ctx context.Context, options *ShareCreateOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	if options != nil && options.Quota != nil {
		req.Raw().Header.Set("x-ms-share-quota", strconv.FormatInt(int64(*options.Quota), 10))
	}
	if options != nil && options.AccessTier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*options.AccessTier))
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *shareClient) createHandleResponse(resp *http.Response) (ShareCreateResponse, error) {
	result := ShareCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// createHandleError handles the Create error response.
func (client *shareClient) createHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreatePermission - Create a permission (a security descriptor).
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) CreatePermission(ctx context.Context, sharePermission SharePermission, options *ShareCreatePermissionOptions) (ShareCreatePermissionResponse, error) {
	req, err := client.createPermissionCreateRequest(ctx, sharePermission, options)
	if err != nil {
		return ShareCreatePermissionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreatePermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreatePermissionResponse{}, client.createPermissionHandleError(resp)
	}
	return client.createPermissionHandleResponse(resp)
}

// createPermissionCreateRequest creates the CreatePermission request.
func (client *shareClient) createPermissionCreateRequest(ctx context.Context, sharePermission SharePermission, options *ShareCreatePermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, runtime.MarshalAsJSON(req, sharePermission)
}

// createPermissionHandleResponse handles the CreatePermission response.
func (client *shareClient) createPermissionHandleResponse(resp *http.Response) (ShareCreatePermissionResponse, error) {
	result := ShareCreatePermissionResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreatePermissionResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	return result, nil
}

// createPermissionHandleError handles the CreatePermission error response.
func (client *shareClient) createPermissionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateSnapshot - Creates a read-only snapshot of a share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) CreateSnapshot(ctx context.Context, options *ShareCreateSnapshotOptions) (ShareCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(ctx, options)
	if err != nil {
		return ShareCreateSnapshotResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareCreateSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareCreateSnapshotResponse{}, client.createSnapshotHandleError(resp)
	}
	return client.createSnapshotHandleResponse(resp)
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *shareClient) createSnapshotCreateRequest(ctx context.Context, options *ShareCreateSnapshotOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "snapshot")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *shareClient) createSnapshotHandleResponse(resp *http.Response) (ShareCreateSnapshotResponse, error) {
	result := ShareCreateSnapshotResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateSnapshotResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareCreateSnapshotResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// createSnapshotHandleError handles the CreateSnapshot error response.
func (client *shareClient) createSnapshotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Operation marks the specified share or share snapshot for deletion. The share or share snapshot and any files contained within it are later
// deleted during garbage collection.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Delete(ctx context.Context, shareDeleteOptions *ShareDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (ShareDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, shareDeleteOptions, leaseAccessConditions)
	if err != nil {
		return ShareDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return ShareDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *shareClient) deleteCreateRequest(ctx context.Context, shareDeleteOptions *ShareDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if shareDeleteOptions != nil && shareDeleteOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *shareDeleteOptions.Sharesnapshot)
	}
	if shareDeleteOptions != nil && shareDeleteOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareDeleteOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if shareDeleteOptions != nil && shareDeleteOptions.DeleteSnapshots != nil {
		req.Raw().Header.Set("x-ms-delete-snapshots", string(*shareDeleteOptions.DeleteSnapshots))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *shareClient) deleteHandleResponse(resp *http.Response) (ShareDeleteResponse, error) {
	result := ShareDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *shareClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAccessPolicy - Returns information about stored access policies specified on the share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetAccessPolicy(ctx context.Context, shareGetAccessPolicyOptions *ShareGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (ShareGetAccessPolicyResponse, error) {
	req, err := client.getAccessPolicyCreateRequest(ctx, shareGetAccessPolicyOptions, leaseAccessConditions)
	if err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetAccessPolicyResponse{}, client.getAccessPolicyHandleError(resp)
	}
	return client.getAccessPolicyHandleResponse(resp)
}

// getAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *shareClient) getAccessPolicyCreateRequest(ctx context.Context, shareGetAccessPolicyOptions *ShareGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if shareGetAccessPolicyOptions != nil && shareGetAccessPolicyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareGetAccessPolicyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *shareClient) getAccessPolicyHandleResponse(resp *http.Response) (ShareGetAccessPolicyResponse, error) {
	result := ShareGetAccessPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return ShareGetAccessPolicyResponse{}, err
	}
	return result, nil
}

// getAccessPolicyHandleError handles the GetAccessPolicy error response.
func (client *shareClient) getAccessPolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPermission - Returns the permission (security descriptor) for a given key
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetPermission(ctx context.Context, filePermissionKey string, options *ShareGetPermissionOptions) (ShareGetPermissionResponse, error) {
	req, err := client.getPermissionCreateRequest(ctx, filePermissionKey, options)
	if err != nil {
		return ShareGetPermissionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetPermissionResponse{}, client.getPermissionHandleError(resp)
	}
	return client.getPermissionHandleResponse(resp)
}

// getPermissionCreateRequest creates the GetPermission request.
func (client *shareClient) getPermissionCreateRequest(ctx context.Context, filePermissionKey string, options *ShareGetPermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-file-permission-key", filePermissionKey)
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPermissionHandleResponse handles the GetPermission response.
func (client *shareClient) getPermissionHandleResponse(resp *http.Response) (ShareGetPermissionResponse, error) {
	result := ShareGetPermissionResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPermissionResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SharePermission); err != nil {
		return ShareGetPermissionResponse{}, err
	}
	return result, nil
}

// getPermissionHandleError handles the GetPermission error response.
func (client *shareClient) getPermissionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetProperties - Returns all user-defined metadata and system properties for the specified share or share snapshot. The data returned does not include
// the share's list of files.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetProperties(ctx context.Context, shareGetPropertiesOptions *ShareGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (ShareGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, shareGetPropertiesOptions, leaseAccessConditions)
	if err != nil {
		return ShareGetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetPropertiesResponse{}, client.getPropertiesHandleError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *shareClient) getPropertiesCreateRequest(ctx context.Context, shareGetPropertiesOptions *ShareGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if shareGetPropertiesOptions != nil && shareGetPropertiesOptions.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *shareGetPropertiesOptions.Sharesnapshot)
	}
	if shareGetPropertiesOptions != nil && shareGetPropertiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareGetPropertiesOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *shareClient) getPropertiesHandleResponse(resp *http.Response) (ShareGetPropertiesResponse, error) {
	result := ShareGetPropertiesResponse{RawResponse: resp}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-share-quota"); val != "" {
		quota32, err := strconv.ParseInt(val, 10, 32)
		quota := int32(quota32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.Quota = &quota
	}
	if val := resp.Header.Get("x-ms-share-provisioned-iops"); val != "" {
		provisionedIops32, err := strconv.ParseInt(val, 10, 32)
		provisionedIops := int32(provisionedIops32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedIops = &provisionedIops
	}
	if val := resp.Header.Get("x-ms-share-provisioned-ingress-mbps"); val != "" {
		provisionedIngressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedIngressMBps := int32(provisionedIngressMBps32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedIngressMBps = &provisionedIngressMBps
	}
	if val := resp.Header.Get("x-ms-share-provisioned-egress-mbps"); val != "" {
		provisionedEgressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedEgressMBps := int32(provisionedEgressMBps32)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.ProvisionedEgressMBps = &provisionedEgressMBps
	}
	if val := resp.Header.Get("x-ms-share-next-allowed-quota-downgrade-time"); val != "" {
		nextAllowedQuotaDowngradeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.NextAllowedQuotaDowngradeTime = &nextAllowedQuotaDowngradeTime
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetPropertiesResponse{}, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	if val := resp.Header.Get("x-ms-access-tier-transition-state"); val != "" {
		result.AccessTierTransitionState = &val
	}
	return result, nil
}

// getPropertiesHandleError handles the GetProperties error response.
func (client *shareClient) getPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetStatistics - Retrieves statistics related to the share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) GetStatistics(ctx context.Context, shareGetStatisticsOptions *ShareGetStatisticsOptions, leaseAccessConditions *LeaseAccessConditions) (ShareGetStatisticsResponse, error) {
	req, err := client.getStatisticsCreateRequest(ctx, shareGetStatisticsOptions, leaseAccessConditions)
	if err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareGetStatisticsResponse{}, client.getStatisticsHandleError(resp)
	}
	return client.getStatisticsHandleResponse(resp)
}

// getStatisticsCreateRequest creates the GetStatistics request.
func (client *shareClient) getStatisticsCreateRequest(ctx context.Context, shareGetStatisticsOptions *ShareGetStatisticsOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "stats")
	if shareGetStatisticsOptions != nil && shareGetStatisticsOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareGetStatisticsOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getStatisticsHandleResponse handles the GetStatistics response.
func (client *shareClient) getStatisticsHandleResponse(resp *http.Response) (ShareGetStatisticsResponse, error) {
	result := ShareGetStatisticsResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetStatisticsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareGetStatisticsResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ShareStats); err != nil {
		return ShareGetStatisticsResponse{}, err
	}
	return result, nil
}

// getStatisticsHandleError handles the GetStatistics error response.
func (client *shareClient) getStatisticsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ReleaseLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and delete share operations.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) ReleaseLease(ctx context.Context, leaseID string, options *ShareReleaseLeaseOptions) (ShareReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return ShareReleaseLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareReleaseLeaseResponse{}, client.releaseLeaseHandleError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *shareClient) releaseLeaseCreateRequest(ctx context.Context, leaseID string, options *ShareReleaseLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "release")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *shareClient) releaseLeaseHandleResponse(resp *http.Response) (ShareReleaseLeaseResponse, error) {
	result := ShareReleaseLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// releaseLeaseHandleError handles the ReleaseLease error response.
func (client *shareClient) releaseLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RenewLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and delete share operations.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) RenewLease(ctx context.Context, leaseID string, options *ShareRenewLeaseOptions) (ShareRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return ShareRenewLeaseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareRenewLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareRenewLeaseResponse{}, client.renewLeaseHandleError(resp)
	}
	return client.renewLeaseHandleResponse(resp)
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *shareClient) renewLeaseCreateRequest(ctx context.Context, leaseID string, options *ShareRenewLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-lease-action", "renew")
	req.Raw().Header.Set("x-ms-lease-id", leaseID)
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *shareClient) renewLeaseHandleResponse(resp *http.Response) (ShareRenewLeaseResponse, error) {
	result := ShareRenewLeaseResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRenewLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRenewLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// renewLeaseHandleError handles the RenewLease error response.
func (client *shareClient) renewLeaseHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Restore - Restores a previously deleted Share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) Restore(ctx context.Context, options *ShareRestoreOptions) (ShareRestoreResponse, error) {
	req, err := client.restoreCreateRequest(ctx, options)
	if err != nil {
		return ShareRestoreResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareRestoreResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ShareRestoreResponse{}, client.restoreHandleError(resp)
	}
	return client.restoreHandleResponse(resp)
}

// restoreCreateRequest creates the Restore request.
func (client *shareClient) restoreCreateRequest(ctx context.Context, options *ShareRestoreOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if options != nil && options.RequestID != nil {
		req.Raw().Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	if options != nil && options.DeletedShareName != nil {
		req.Raw().Header.Set("x-ms-deleted-share-name", *options.DeletedShareName)
	}
	if options != nil && options.DeletedShareVersion != nil {
		req.Raw().Header.Set("x-ms-deleted-share-version", *options.DeletedShareVersion)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// restoreHandleResponse handles the Restore response.
func (client *shareClient) restoreHandleResponse(resp *http.Response) (ShareRestoreResponse, error) {
	result := ShareRestoreResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRestoreResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareRestoreResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// restoreHandleError handles the Restore error response.
func (client *shareClient) restoreHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetAccessPolicy - Sets a stored access policy for use with shared access signatures.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetAccessPolicy(ctx context.Context, shareSetAccessPolicyOptions *ShareSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (ShareSetAccessPolicyResponse, error) {
	req, err := client.setAccessPolicyCreateRequest(ctx, shareSetAccessPolicyOptions, leaseAccessConditions)
	if err != nil {
		return ShareSetAccessPolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetAccessPolicyResponse{}, client.setAccessPolicyHandleError(resp)
	}
	return client.setAccessPolicyHandleResponse(resp)
}

// setAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *shareClient) setAccessPolicyCreateRequest(ctx context.Context, shareSetAccessPolicyOptions *ShareSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if shareSetAccessPolicyOptions != nil && shareSetAccessPolicyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareSetAccessPolicyOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	type wrapper struct {
		XMLName  xml.Name             `xml:"SignedIdentifiers"`
		ShareACL *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	if shareSetAccessPolicyOptions != nil && shareSetAccessPolicyOptions.ShareACL != nil {
		return req, runtime.MarshalAsXML(req, wrapper{ShareACL: &shareSetAccessPolicyOptions.ShareACL})
	}
	return req, nil
}

// setAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *shareClient) setAccessPolicyHandleResponse(resp *http.Response) (ShareSetAccessPolicyResponse, error) {
	result := ShareSetAccessPolicyResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setAccessPolicyHandleError handles the SetAccessPolicy error response.
func (client *shareClient) setAccessPolicyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetMetadata - Sets one or more user-defined name-value pairs for the specified share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetMetadata(ctx context.Context, shareSetMetadataOptions *ShareSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (ShareSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, shareSetMetadataOptions, leaseAccessConditions)
	if err != nil {
		return ShareSetMetadataResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetMetadataResponse{}, client.setMetadataHandleError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *shareClient) setMetadataCreateRequest(ctx context.Context, shareSetMetadataOptions *ShareSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "metadata")
	if shareSetMetadataOptions != nil && shareSetMetadataOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareSetMetadataOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if shareSetMetadataOptions != nil && shareSetMetadataOptions.Metadata != nil {
		for k, v := range shareSetMetadataOptions.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *shareClient) setMetadataHandleResponse(resp *http.Response) (ShareSetMetadataResponse, error) {
	result := ShareSetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setMetadataHandleError handles the SetMetadata error response.
func (client *shareClient) setMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetProperties - Sets properties for the specified share.
// If the operation fails it returns the *StorageError error type.
func (client *shareClient) SetProperties(ctx context.Context, shareSetPropertiesOptions *ShareSetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (ShareSetPropertiesResponse, error) {
	req, err := client.setPropertiesCreateRequest(ctx, shareSetPropertiesOptions, leaseAccessConditions)
	if err != nil {
		return ShareSetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ShareSetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ShareSetPropertiesResponse{}, client.setPropertiesHandleError(resp)
	}
	return client.setPropertiesHandleResponse(resp)
}

// setPropertiesCreateRequest creates the SetProperties request.
func (client *shareClient) setPropertiesCreateRequest(ctx context.Context, shareSetPropertiesOptions *ShareSetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "properties")
	if shareSetPropertiesOptions != nil && shareSetPropertiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*shareSetPropertiesOptions.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2020-02-10")
	if shareSetPropertiesOptions != nil && shareSetPropertiesOptions.Quota != nil {
		req.Raw().Header.Set("x-ms-share-quota", strconv.FormatInt(int64(*shareSetPropertiesOptions.Quota), 10))
	}
	if shareSetPropertiesOptions != nil && shareSetPropertiesOptions.AccessTier != nil {
		req.Raw().Header.Set("x-ms-access-tier", string(*shareSetPropertiesOptions.AccessTier))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseID)
	}
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setPropertiesHandleResponse handles the SetProperties response.
func (client *shareClient) setPropertiesHandleResponse(resp *http.Response) (ShareSetPropertiesResponse, error) {
	result := ShareSetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return ShareSetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setPropertiesHandleError handles the SetProperties error response.
func (client *shareClient) setPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
