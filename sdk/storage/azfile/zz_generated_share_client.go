//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"encoding/xml"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type shareClient struct {
	endpoint string
	pl       runtime.Pipeline
}

// newShareClient creates a new instance of shareClient with the specified values.
// endpoint - The URL of the service account, share, directory or file that is the target of the desired operation.
// pl - the pipeline used for sending requests and handling responses.
func newShareClient(endpoint string, pl runtime.Pipeline) *shareClient {
	client := &shareClient{
		endpoint: endpoint,
		pl:       pl,
	}
	return client
}

// AcquireLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and
// delete share operations.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientAcquireLeaseOptions contains the optional parameters for the shareClient.AcquireLease method.
func (client *shareClient) AcquireLease(ctx context.Context, options *shareClientAcquireLeaseOptions) (shareClientAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, options)
	if err != nil {
		return shareClientAcquireLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientAcquireLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return shareClientAcquireLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.acquireLeaseHandleResponse(resp)
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *shareClient) acquireLeaseCreateRequest(ctx context.Context, options *shareClientAcquireLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"acquire"}
	if options != nil && options.Duration != nil {
		req.Raw().Header["x-ms-lease-duration"] = []string{strconv.FormatInt(int64(*options.Duration), 10)}
	}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header["x-ms-proposed-lease-id"] = []string{*options.ProposedLeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *shareClient) acquireLeaseHandleResponse(resp *http.Response) (shareClientAcquireLeaseResponse, error) {
	result := shareClientAcquireLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// BreakLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and
// delete share operations.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientBreakLeaseOptions contains the optional parameters for the shareClient.BreakLease method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) BreakLease(ctx context.Context, options *shareClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientBreakLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientBreakLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return shareClientBreakLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.breakLeaseHandleResponse(resp)
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *shareClient) breakLeaseCreateRequest(ctx context.Context, options *shareClientBreakLeaseOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"break"}
	if options != nil && options.BreakPeriod != nil {
		req.Raw().Header["x-ms-lease-break-period"] = []string{strconv.FormatInt(int64(*options.BreakPeriod), 10)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *shareClient) breakLeaseHandleResponse(resp *http.Response) (shareClientBreakLeaseResponse, error) {
	result := shareClientBreakLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return shareClientBreakLeaseResponse{}, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// ChangeLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and
// delete share operations.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// leaseID - Specifies the current lease ID on the resource.
// options - shareClientChangeLeaseOptions contains the optional parameters for the shareClient.ChangeLease method.
func (client *shareClient) ChangeLease(ctx context.Context, leaseID string, options *shareClientChangeLeaseOptions) (shareClientChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return shareClientChangeLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientChangeLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientChangeLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.changeLeaseHandleResponse(resp)
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *shareClient) changeLeaseCreateRequest(ctx context.Context, leaseID string, options *shareClientChangeLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"change"}
	req.Raw().Header["x-ms-lease-id"] = []string{leaseID}
	if options != nil && options.ProposedLeaseID != nil {
		req.Raw().Header["x-ms-proposed-lease-id"] = []string{*options.ProposedLeaseID}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *shareClient) changeLeaseHandleResponse(resp *http.Response) (shareClientChangeLeaseResponse, error) {
	result := shareClientChangeLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Create - Creates a new share under the specified account. If the share with the same name already exists, the operation
// fails.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientCreateOptions contains the optional parameters for the shareClient.Create method.
func (client *shareClient) Create(ctx context.Context, options *shareClientCreateOptions) (shareClientCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, options)
	if err != nil {
		return shareClientCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return shareClientCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *shareClient) createCreateRequest(ctx context.Context, options *shareClientCreateOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	if options != nil && options.Quota != nil {
		req.Raw().Header["x-ms-share-quota"] = []string{strconv.FormatInt(int64(*options.Quota), 10)}
	}
	if options != nil && options.AccessTier != nil {
		req.Raw().Header["x-ms-access-tier"] = []string{string(*options.AccessTier)}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.EnabledProtocols != nil {
		req.Raw().Header["x-ms-enabled-protocols"] = []string{*options.EnabledProtocols}
	}
	if options != nil && options.RootSquash != nil {
		req.Raw().Header["x-ms-root-squash"] = []string{string(*options.RootSquash)}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *shareClient) createHandleResponse(resp *http.Response) (shareClientCreateResponse, error) {
	result := shareClientCreateResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientCreateResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// CreatePermission - Create a permission (a security descriptor).
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// sharePermission - A permission (a security descriptor) at the share level.
// options - shareClientCreatePermissionOptions contains the optional parameters for the shareClient.CreatePermission method.
func (client *shareClient) CreatePermission(ctx context.Context, sharePermission SharePermission, options *shareClientCreatePermissionOptions) (shareClientCreatePermissionResponse, error) {
	req, err := client.createPermissionCreateRequest(ctx, sharePermission, options)
	if err != nil {
		return shareClientCreatePermissionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientCreatePermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return shareClientCreatePermissionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createPermissionHandleResponse(resp)
}

// createPermissionCreateRequest creates the CreatePermission request.
func (client *shareClient) createPermissionCreateRequest(ctx context.Context, sharePermission SharePermission, options *shareClientCreatePermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, runtime.MarshalAsJSON(req, sharePermission)
}

// createPermissionHandleResponse handles the CreatePermission response.
func (client *shareClient) createPermissionHandleResponse(resp *http.Response) (shareClientCreatePermissionResponse, error) {
	result := shareClientCreatePermissionResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientCreatePermissionResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	return result, nil
}

// CreateSnapshot - Creates a read-only snapshot of a share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientCreateSnapshotOptions contains the optional parameters for the shareClient.CreateSnapshot method.
func (client *shareClient) CreateSnapshot(ctx context.Context, options *shareClientCreateSnapshotOptions) (shareClientCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(ctx, options)
	if err != nil {
		return shareClientCreateSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientCreateSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return shareClientCreateSnapshotResponse{}, runtime.NewResponseError(resp)
	}
	return client.createSnapshotHandleResponse(resp)
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *shareClient) createSnapshotCreateRequest(ctx context.Context, options *shareClientCreateSnapshotOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "snapshot")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *shareClient) createSnapshotHandleResponse(resp *http.Response) (shareClientCreateSnapshotResponse, error) {
	result := shareClientCreateSnapshotResponse{}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientCreateSnapshotResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientCreateSnapshotResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Delete - Operation marks the specified share or share snapshot for deletion. The share or share snapshot and any files
// contained within it are later deleted during garbage collection.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientDeleteOptions contains the optional parameters for the shareClient.Delete method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) Delete(ctx context.Context, options *shareClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return shareClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *shareClient) deleteCreateRequest(ctx context.Context, options *shareClientDeleteOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.DeleteSnapshots != nil {
		req.Raw().Header["x-ms-delete-snapshots"] = []string{string(*options.DeleteSnapshots)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *shareClient) deleteHandleResponse(resp *http.Response) (shareClientDeleteResponse, error) {
	result := shareClientDeleteResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// GetAccessPolicy - Returns information about stored access policies specified on the share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientGetAccessPolicyOptions contains the optional parameters for the shareClient.GetAccessPolicy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) GetAccessPolicy(ctx context.Context, options *shareClientGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientGetAccessPolicyResponse, error) {
	req, err := client.getAccessPolicyCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientGetAccessPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientGetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientGetAccessPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.getAccessPolicyHandleResponse(resp)
}

// getAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *shareClient) getAccessPolicyCreateRequest(ctx context.Context, options *shareClientGetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *shareClient) getAccessPolicyHandleResponse(resp *http.Response) (shareClientGetAccessPolicyResponse, error) {
	result := shareClientGetAccessPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result); err != nil {
		return shareClientGetAccessPolicyResponse{}, err
	}
	return result, nil
}

// GetPermission - Returns the permission (security descriptor) for a given key
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// filePermissionKey - Key of the permission to be set for the directory/file.
// options - shareClientGetPermissionOptions contains the optional parameters for the shareClient.GetPermission method.
func (client *shareClient) GetPermission(ctx context.Context, filePermissionKey string, options *shareClientGetPermissionOptions) (shareClientGetPermissionResponse, error) {
	req, err := client.getPermissionCreateRequest(ctx, filePermissionKey, options)
	if err != nil {
		return shareClientGetPermissionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientGetPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientGetPermissionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPermissionHandleResponse(resp)
}

// getPermissionCreateRequest creates the GetPermission request.
func (client *shareClient) getPermissionCreateRequest(ctx context.Context, filePermissionKey string, options *shareClientGetPermissionOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "filepermission")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-file-permission-key"] = []string{filePermissionKey}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getPermissionHandleResponse handles the GetPermission response.
func (client *shareClient) getPermissionHandleResponse(resp *http.Response) (shareClientGetPermissionResponse, error) {
	result := shareClientGetPermissionResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetPermissionResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.SharePermission); err != nil {
		return shareClientGetPermissionResponse{}, err
	}
	return result, nil
}

// GetProperties - Returns all user-defined metadata and system properties for the specified share or share snapshot. The
// data returned does not include the share's list of files.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientGetPropertiesOptions contains the optional parameters for the shareClient.GetProperties method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) GetProperties(ctx context.Context, options *shareClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *shareClient) getPropertiesCreateRequest(ctx context.Context, options *shareClientGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *shareClient) getPropertiesHandleResponse(resp *http.Response) (shareClientGetPropertiesResponse, error) {
	result := shareClientGetPropertiesResponse{}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-share-quota"); val != "" {
		quota32, err := strconv.ParseInt(val, 10, 32)
		quota := int32(quota32)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.Quota = &quota
	}
	if val := resp.Header.Get("x-ms-share-provisioned-iops"); val != "" {
		provisionedIops32, err := strconv.ParseInt(val, 10, 32)
		provisionedIops := int32(provisionedIops32)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.ProvisionedIops = &provisionedIops
	}
	if val := resp.Header.Get("x-ms-share-provisioned-ingress-mbps"); val != "" {
		provisionedIngressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedIngressMBps := int32(provisionedIngressMBps32)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.ProvisionedIngressMBps = &provisionedIngressMBps
	}
	if val := resp.Header.Get("x-ms-share-provisioned-egress-mbps"); val != "" {
		provisionedEgressMBps32, err := strconv.ParseInt(val, 10, 32)
		provisionedEgressMBps := int32(provisionedEgressMBps32)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.ProvisionedEgressMBps = &provisionedEgressMBps
	}
	if val := resp.Header.Get("x-ms-share-next-allowed-quota-downgrade-time"); val != "" {
		nextAllowedQuotaDowngradeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.NextAllowedQuotaDowngradeTime = &nextAllowedQuotaDowngradeTime
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetPropertiesResponse{}, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	if val := resp.Header.Get("x-ms-access-tier-transition-state"); val != "" {
		result.AccessTierTransitionState = &val
	}
	if val := resp.Header.Get("x-ms-enabled-protocols"); val != "" {
		result.EnabledProtocols = &val
	}
	if val := resp.Header.Get("x-ms-root-squash"); val != "" {
		result.RootSquash = (*ShareRootSquash)(&val)
	}
	return result, nil
}

// GetStatistics - Retrieves statistics related to the share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientGetStatisticsOptions contains the optional parameters for the shareClient.GetStatistics method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) GetStatistics(ctx context.Context, options *shareClientGetStatisticsOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientGetStatisticsResponse, error) {
	req, err := client.getStatisticsCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientGetStatisticsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientGetStatisticsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientGetStatisticsResponse{}, runtime.NewResponseError(resp)
	}
	return client.getStatisticsHandleResponse(resp)
}

// getStatisticsCreateRequest creates the GetStatistics request.
func (client *shareClient) getStatisticsCreateRequest(ctx context.Context, options *shareClientGetStatisticsOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "stats")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getStatisticsHandleResponse handles the GetStatistics response.
func (client *shareClient) getStatisticsHandleResponse(resp *http.Response) (shareClientGetStatisticsResponse, error) {
	result := shareClientGetStatisticsResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetStatisticsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientGetStatisticsResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ShareStats); err != nil {
		return shareClientGetStatisticsResponse{}, err
	}
	return result, nil
}

// ReleaseLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and
// delete share operations.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// leaseID - Specifies the current lease ID on the resource.
// options - shareClientReleaseLeaseOptions contains the optional parameters for the shareClient.ReleaseLease method.
func (client *shareClient) ReleaseLease(ctx context.Context, leaseID string, options *shareClientReleaseLeaseOptions) (shareClientReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return shareClientReleaseLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientReleaseLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientReleaseLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.releaseLeaseHandleResponse(resp)
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *shareClient) releaseLeaseCreateRequest(ctx context.Context, leaseID string, options *shareClientReleaseLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"release"}
	req.Raw().Header["x-ms-lease-id"] = []string{leaseID}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *shareClient) releaseLeaseHandleResponse(resp *http.Response) (shareClientReleaseLeaseResponse, error) {
	result := shareClientReleaseLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// RenewLease - The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for set and
// delete share operations.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// leaseID - Specifies the current lease ID on the resource.
// options - shareClientRenewLeaseOptions contains the optional parameters for the shareClient.RenewLease method.
func (client *shareClient) RenewLease(ctx context.Context, leaseID string, options *shareClientRenewLeaseOptions) (shareClientRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(ctx, leaseID, options)
	if err != nil {
		return shareClientRenewLeaseResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientRenewLeaseResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientRenewLeaseResponse{}, runtime.NewResponseError(resp)
	}
	return client.renewLeaseHandleResponse(resp)
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *shareClient) renewLeaseCreateRequest(ctx context.Context, leaseID string, options *shareClientRenewLeaseOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "lease")
	reqQP.Set("restype", "share")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-lease-action"] = []string{"renew"}
	req.Raw().Header["x-ms-lease-id"] = []string{leaseID}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *shareClient) renewLeaseHandleResponse(resp *http.Response) (shareClientRenewLeaseResponse, error) {
	result := shareClientRenewLeaseResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientRenewLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientRenewLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// Restore - Restores a previously deleted Share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientRestoreOptions contains the optional parameters for the shareClient.Restore method.
func (client *shareClient) Restore(ctx context.Context, options *shareClientRestoreOptions) (shareClientRestoreResponse, error) {
	req, err := client.restoreCreateRequest(ctx, options)
	if err != nil {
		return shareClientRestoreResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientRestoreResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return shareClientRestoreResponse{}, runtime.NewResponseError(resp)
	}
	return client.restoreHandleResponse(resp)
}

// restoreCreateRequest creates the Restore request.
func (client *shareClient) restoreCreateRequest(ctx context.Context, options *shareClientRestoreOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-client-request-id"] = []string{*options.RequestID}
	}
	if options != nil && options.DeletedShareName != nil {
		req.Raw().Header["x-ms-deleted-share-name"] = []string{*options.DeletedShareName}
	}
	if options != nil && options.DeletedShareVersion != nil {
		req.Raw().Header["x-ms-deleted-share-version"] = []string{*options.DeletedShareVersion}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// restoreHandleResponse handles the Restore response.
func (client *shareClient) restoreHandleResponse(resp *http.Response) (shareClientRestoreResponse, error) {
	result := shareClientRestoreResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientRestoreResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientRestoreResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetAccessPolicy - Sets a stored access policy for use with shared access signatures.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientSetAccessPolicyOptions contains the optional parameters for the shareClient.SetAccessPolicy method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) SetAccessPolicy(ctx context.Context, options *shareClientSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientSetAccessPolicyResponse, error) {
	req, err := client.setAccessPolicyCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientSetAccessPolicyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientSetAccessPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientSetAccessPolicyResponse{}, runtime.NewResponseError(resp)
	}
	return client.setAccessPolicyHandleResponse(resp)
}

// setAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *shareClient) setAccessPolicyCreateRequest(ctx context.Context, options *shareClientSetAccessPolicyOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	type wrapper struct {
		XMLName  xml.Name             `xml:"SignedIdentifiers"`
		ShareACL *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	if options != nil && options.ShareACL != nil {
		return req, runtime.MarshalAsXML(req, wrapper{ShareACL: &options.ShareACL})
	}
	return req, nil
}

// setAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *shareClient) setAccessPolicyHandleResponse(resp *http.Response) (shareClientSetAccessPolicyResponse, error) {
	result := shareClientSetAccessPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetAccessPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetMetadata - Sets one or more user-defined name-value pairs for the specified share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientSetMetadataOptions contains the optional parameters for the shareClient.SetMetadata method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) SetMetadata(ctx context.Context, options *shareClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientSetMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientSetMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *shareClient) setMetadataCreateRequest(ctx context.Context, options *shareClientSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *shareClient) setMetadataHandleResponse(resp *http.Response) (shareClientSetMetadataResponse, error) {
	result := shareClientSetMetadataResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// SetProperties - Sets properties for the specified share.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - shareClientSetPropertiesOptions contains the optional parameters for the shareClient.SetProperties method.
// LeaseAccessConditions - LeaseAccessConditions contains a group of parameters for the shareClient.GetProperties method.
func (client *shareClient) SetProperties(ctx context.Context, options *shareClientSetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (shareClientSetPropertiesResponse, error) {
	req, err := client.setPropertiesCreateRequest(ctx, options, leaseAccessConditions)
	if err != nil {
		return shareClientSetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return shareClientSetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return shareClientSetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.setPropertiesHandleResponse(resp)
}

// setPropertiesCreateRequest creates the SetProperties request.
func (client *shareClient) setPropertiesCreateRequest(ctx context.Context, options *shareClientSetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "share")
	reqQP.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.Quota != nil {
		req.Raw().Header["x-ms-share-quota"] = []string{strconv.FormatInt(int64(*options.Quota), 10)}
	}
	if options != nil && options.AccessTier != nil {
		req.Raw().Header["x-ms-access-tier"] = []string{string(*options.AccessTier)}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseID != nil {
		req.Raw().Header["x-ms-lease-id"] = []string{*leaseAccessConditions.LeaseID}
	}
	if options != nil && options.RootSquash != nil {
		req.Raw().Header["x-ms-root-squash"] = []string{string(*options.RootSquash)}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setPropertiesHandleResponse handles the SetProperties response.
func (client *shareClient) setPropertiesHandleResponse(resp *http.Response) (shareClientSetPropertiesResponse, error) {
	result := shareClientSetPropertiesResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return shareClientSetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}
