//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type directoryClient struct {
	con *connection
}

// Create - Creates a new directory under the specified share or parent directory.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) Create(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, options *DirectoryCreateOptions) (DirectoryCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, options)
	if err != nil {
		return DirectoryCreateResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectoryCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return DirectoryCreateResponse{}, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *directoryClient) createCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, options *DirectoryCreateOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *options.FilePermission)
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *options.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime.Format(time.RFC1123))
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime.Format(time.RFC1123))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *directoryClient) createHandleResponse(resp *http.Response) (DirectoryCreateResponse, error) {
	result := DirectoryCreateResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryCreateResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// createHandleError handles the Create error response.
func (client *directoryClient) createHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Removes the specified empty directory. Note that the directory must be empty before it can be deleted.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) Delete(ctx context.Context, options *DirectoryDeleteOptions) (DirectoryDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, options)
	if err != nil {
		return DirectoryDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectoryDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return DirectoryDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *directoryClient) deleteCreateRequest(ctx context.Context, options *DirectoryDeleteOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *directoryClient) deleteHandleResponse(resp *http.Response) (DirectoryDeleteResponse, error) {
	result := DirectoryDeleteResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *directoryClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ForceCloseHandles - Closes all handles open for given directory.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) ForceCloseHandles(ctx context.Context, handleID string, options *DirectoryForceCloseHandlesOptions) (DirectoryForceCloseHandlesResponse, error) {
	req, err := client.forceCloseHandlesCreateRequest(ctx, handleID, options)
	if err != nil {
		return DirectoryForceCloseHandlesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectoryForceCloseHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DirectoryForceCloseHandlesResponse{}, client.forceCloseHandlesHandleError(resp)
	}
	return client.forceCloseHandlesHandleResponse(resp)
}

// forceCloseHandlesCreateRequest creates the ForceCloseHandles request.
func (client *directoryClient) forceCloseHandlesCreateRequest(ctx context.Context, handleID string, options *DirectoryForceCloseHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "forceclosehandles")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-handle-id", handleID)
	if options != nil && options.Recursive != nil {
		req.Raw().Header.Set("x-ms-recursive", strconv.FormatBool(*options.Recursive))
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// forceCloseHandlesHandleResponse handles the ForceCloseHandles response.
func (client *directoryClient) forceCloseHandlesHandleResponse(resp *http.Response) (DirectoryForceCloseHandlesResponse, error) {
	result := DirectoryForceCloseHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryForceCloseHandlesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-marker"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-number-of-handles-closed"); val != "" {
		numberOfHandlesClosed32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesClosed := int32(numberOfHandlesClosed32)
		if err != nil {
			return DirectoryForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesClosed = &numberOfHandlesClosed
	}
	if val := resp.Header.Get("x-ms-number-of-handles-failed"); val != "" {
		numberOfHandlesFailedToClose32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesFailedToClose := int32(numberOfHandlesFailedToClose32)
		if err != nil {
			return DirectoryForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesFailedToClose = &numberOfHandlesFailedToClose
	}
	return result, nil
}

// forceCloseHandlesHandleError handles the ForceCloseHandles error response.
func (client *directoryClient) forceCloseHandlesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetProperties - Returns all system properties for the specified directory, and can also be used to check the existence of a directory. The data returned
// does not include the files in the directory or any
// subdirectories.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) GetProperties(ctx context.Context, options *DirectoryGetPropertiesOptions) (DirectoryGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, options)
	if err != nil {
		return DirectoryGetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectoryGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DirectoryGetPropertiesResponse{}, client.getPropertiesHandleError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *directoryClient) getPropertiesCreateRequest(ctx context.Context, options *DirectoryGetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *directoryClient) getPropertiesHandleResponse(resp *http.Response) (DirectoryGetPropertiesResponse, error) {
	result := DirectoryGetPropertiesResponse{RawResponse: resp}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryGetPropertiesResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// getPropertiesHandleError handles the GetProperties error response.
func (client *directoryClient) getPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFilesAndDirectoriesSegment - Returns a list of files or directories under the specified share or directory. It lists the contents only for a single
// level of the directory hierarchy.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) ListFilesAndDirectoriesSegment(options *DirectoryListFilesAndDirectoriesSegmentOptions) *DirectoryListFilesAndDirectoriesSegmentPager {
	return &DirectoryListFilesAndDirectoriesSegmentPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listFilesAndDirectoriesSegmentCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp DirectoryListFilesAndDirectoriesSegmentResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ListFilesAndDirectoriesSegmentResponse.NextMarker)
		},
	}
}

// listFilesAndDirectoriesSegmentCreateRequest creates the ListFilesAndDirectoriesSegment request.
func (client *directoryClient) listFilesAndDirectoriesSegmentCreateRequest(ctx context.Context, options *DirectoryListFilesAndDirectoriesSegmentOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "list")
	if options != nil && options.Prefix != nil {
		reqQP.Set("prefix", *options.Prefix)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// listFilesAndDirectoriesSegmentHandleResponse handles the ListFilesAndDirectoriesSegment response.
func (client *directoryClient) listFilesAndDirectoriesSegmentHandleResponse(resp *http.Response) (DirectoryListFilesAndDirectoriesSegmentResponse, error) {
	result := DirectoryListFilesAndDirectoriesSegmentResponse{RawResponse: resp}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryListFilesAndDirectoriesSegmentResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListFilesAndDirectoriesSegmentResponse); err != nil {
		return DirectoryListFilesAndDirectoriesSegmentResponse{}, err
	}
	return result, nil
}

// listFilesAndDirectoriesSegmentHandleError handles the ListFilesAndDirectoriesSegment error response.
func (client *directoryClient) listFilesAndDirectoriesSegmentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHandles - Lists handles for directory.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) ListHandles(ctx context.Context, options *DirectoryListHandlesOptions) (DirectoryListHandlesResponse, error) {
	req, err := client.listHandlesCreateRequest(ctx, options)
	if err != nil {
		return DirectoryListHandlesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectoryListHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DirectoryListHandlesResponse{}, client.listHandlesHandleError(resp)
	}
	return client.listHandlesHandleResponse(resp)
}

// listHandlesCreateRequest creates the ListHandles request.
func (client *directoryClient) listHandlesCreateRequest(ctx context.Context, options *DirectoryListHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "listhandles")
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Recursive != nil {
		req.Raw().Header.Set("x-ms-recursive", strconv.FormatBool(*options.Recursive))
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// listHandlesHandleResponse handles the ListHandles response.
func (client *directoryClient) listHandlesHandleResponse(resp *http.Response) (DirectoryListHandlesResponse, error) {
	result := DirectoryListHandlesResponse{RawResponse: resp}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectoryListHandlesResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListHandlesResponse); err != nil {
		return DirectoryListHandlesResponse{}, err
	}
	return result, nil
}

// listHandlesHandleError handles the ListHandles error response.
func (client *directoryClient) listHandlesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetMetadata - Updates user defined metadata for the specified directory.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) SetMetadata(ctx context.Context, options *DirectorySetMetadataOptions) (DirectorySetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, options)
	if err != nil {
		return DirectorySetMetadataResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectorySetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DirectorySetMetadataResponse{}, client.setMetadataHandleError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *directoryClient) setMetadataCreateRequest(ctx context.Context, options *DirectorySetMetadataOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header.Set("x-ms-meta-"+k, v)
		}
	}
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *directoryClient) setMetadataHandleResponse(resp *http.Response) (DirectorySetMetadataResponse, error) {
	result := DirectorySetMetadataResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return DirectorySetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// setMetadataHandleError handles the SetMetadata error response.
func (client *directoryClient) setMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SetProperties - Sets properties on the directory.
// If the operation fails it returns the *StorageError error type.
func (client *directoryClient) SetProperties(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, options *DirectorySetPropertiesOptions) (DirectorySetPropertiesResponse, error) {
	req, err := client.setPropertiesCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, options)
	if err != nil {
		return DirectorySetPropertiesResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DirectorySetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DirectorySetPropertiesResponse{}, client.setPropertiesHandleError(resp)
	}
	return client.setPropertiesHandleResponse(resp)
}

// setPropertiesCreateRequest creates the SetProperties request.
func (client *directoryClient) setPropertiesCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime time.Time, fileLastWriteTime time.Time, options *DirectorySetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.FilePermission != nil {
		req.Raw().Header.Set("x-ms-file-permission", *options.FilePermission)
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header.Set("x-ms-file-permission-key", *options.FilePermissionKey)
	}
	req.Raw().Header.Set("x-ms-file-attributes", fileAttributes)
	req.Raw().Header.Set("x-ms-file-creation-time", fileCreationTime.Format(time.RFC1123))
	req.Raw().Header.Set("x-ms-file-last-write-time", fileLastWriteTime.Format(time.RFC1123))
	req.Raw().Header.Set("Accept", "application/xml")
	return req, nil
}

// setPropertiesHandleResponse handles the SetProperties response.
func (client *directoryClient) setPropertiesHandleResponse(resp *http.Response) (DirectorySetPropertiesResponse, error) {
	result := DirectorySetPropertiesResponse{RawResponse: resp}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		fileCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.FileCreationTime = &fileCreationTime
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		fileLastWriteTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.FileLastWriteTime = &fileLastWriteTime
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		fileChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return DirectorySetPropertiesResponse{}, err
		}
		result.FileChangeTime = &fileChangeTime
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// setPropertiesHandleError handles the SetProperties error response.
func (client *directoryClient) setPropertiesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := StorageError{raw: string(body)}
	if err := runtime.UnmarshalAsXML(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
