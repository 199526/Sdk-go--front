//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azfile

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type directoryClient struct {
	endpoint string
	pl       runtime.Pipeline
}

// newDirectoryClient creates a new instance of directoryClient with the specified values.
// endpoint - The URL of the service account, share, directory or file that is the target of the desired operation.
// pl - the pipeline used for sending requests and handling responses.
func newDirectoryClient(endpoint string, pl runtime.Pipeline) *directoryClient {
	client := &directoryClient{
		endpoint: endpoint,
		pl:       pl,
	}
	return client
}

// Create - Creates a new directory under the specified share or parent directory.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// options - directoryClientCreateOptions contains the optional parameters for the directoryClient.Create method.
func (client *directoryClient) Create(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *directoryClientCreateOptions) (directoryClientCreateResponse, error) {
	req, err := client.createCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, options)
	if err != nil {
		return directoryClientCreateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientCreateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return directoryClientCreateResponse{}, runtime.NewResponseError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *directoryClient) createCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *directoryClientCreateOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.FilePermission != nil {
		req.Raw().Header["x-ms-file-permission"] = []string{*options.FilePermission}
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header["x-ms-file-permission-key"] = []string{*options.FilePermissionKey}
	}
	req.Raw().Header["x-ms-file-attributes"] = []string{fileAttributes}
	req.Raw().Header["x-ms-file-creation-time"] = []string{fileCreationTime}
	req.Raw().Header["x-ms-file-last-write-time"] = []string{fileLastWriteTime}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *directoryClient) createHandleResponse(resp *http.Response) (directoryClientCreateResponse, error) {
	result := directoryClientCreateResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return directoryClientCreateResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// Delete - Removes the specified empty directory. Note that the directory must be empty before it can be deleted.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - directoryClientDeleteOptions contains the optional parameters for the directoryClient.Delete method.
func (client *directoryClient) Delete(ctx context.Context, options *directoryClientDeleteOptions) (directoryClientDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, options)
	if err != nil {
		return directoryClientDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return directoryClientDeleteResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *directoryClient) deleteCreateRequest(ctx context.Context, options *directoryClientDeleteOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodDelete, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *directoryClient) deleteHandleResponse(resp *http.Response) (directoryClientDeleteResponse, error) {
	result := directoryClientDeleteResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// ForceCloseHandles - Closes all handles open for given directory.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// handleID - Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is a wildcard that specifies
// all handles.
// options - directoryClientForceCloseHandlesOptions contains the optional parameters for the directoryClient.ForceCloseHandles
// method.
func (client *directoryClient) ForceCloseHandles(ctx context.Context, handleID string, options *directoryClientForceCloseHandlesOptions) (directoryClientForceCloseHandlesResponse, error) {
	req, err := client.forceCloseHandlesCreateRequest(ctx, handleID, options)
	if err != nil {
		return directoryClientForceCloseHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientForceCloseHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientForceCloseHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.forceCloseHandlesHandleResponse(resp)
}

// forceCloseHandlesCreateRequest creates the ForceCloseHandles request.
func (client *directoryClient) forceCloseHandlesCreateRequest(ctx context.Context, handleID string, options *directoryClientForceCloseHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "forceclosehandles")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-handle-id"] = []string{handleID}
	if options != nil && options.Recursive != nil {
		req.Raw().Header["x-ms-recursive"] = []string{strconv.FormatBool(*options.Recursive)}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// forceCloseHandlesHandleResponse handles the ForceCloseHandles response.
func (client *directoryClient) forceCloseHandlesHandleResponse(resp *http.Response) (directoryClientForceCloseHandlesResponse, error) {
	result := directoryClientForceCloseHandlesResponse{}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientForceCloseHandlesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-marker"); val != "" {
		result.Marker = &val
	}
	if val := resp.Header.Get("x-ms-number-of-handles-closed"); val != "" {
		numberOfHandlesClosed32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesClosed := int32(numberOfHandlesClosed32)
		if err != nil {
			return directoryClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesClosed = &numberOfHandlesClosed
	}
	if val := resp.Header.Get("x-ms-number-of-handles-failed"); val != "" {
		numberOfHandlesFailedToClose32, err := strconv.ParseInt(val, 10, 32)
		numberOfHandlesFailedToClose := int32(numberOfHandlesFailedToClose32)
		if err != nil {
			return directoryClientForceCloseHandlesResponse{}, err
		}
		result.NumberOfHandlesFailedToClose = &numberOfHandlesFailedToClose
	}
	return result, nil
}

// GetProperties - Returns all system properties for the specified directory, and can also be used to check the existence
// of a directory. The data returned does not include the files in the directory or any
// subdirectories.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - directoryClientGetPropertiesOptions contains the optional parameters for the directoryClient.GetProperties method.
func (client *directoryClient) GetProperties(ctx context.Context, options *directoryClientGetPropertiesOptions) (directoryClientGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, options)
	if err != nil {
		return directoryClientGetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientGetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientGetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.getPropertiesHandleResponse(resp)
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *directoryClient) getPropertiesCreateRequest(ctx context.Context, options *directoryClientGetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *directoryClient) getPropertiesHandleResponse(resp *http.Response) (directoryClientGetPropertiesResponse, error) {
	result := directoryClientGetPropertiesResponse{}
	for hh := range resp.Header {
		if len(hh) > len("x-ms-meta-") && strings.EqualFold(hh[:len("x-ms-meta-")], "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = map[string]string{}
			}
			result.Metadata[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return directoryClientGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}

// NewListFilesAndDirectoriesSegmentPager - Returns a list of files or directories under the specified share or directory.
// It lists the contents only for a single level of the directory hierarchy.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - directoryClientListFilesAndDirectoriesSegmentOptions contains the optional parameters for the directoryClient.ListFilesAndDirectoriesSegment
// method.
func (client *directoryClient) NewListFilesAndDirectoriesSegmentPager(options *directoryClientListFilesAndDirectoriesSegmentOptions) *runtime.Pager[directoryClientListFilesAndDirectoriesSegmentResponse] {
	return runtime.NewPager(runtime.PagingHandler[directoryClientListFilesAndDirectoriesSegmentResponse]{
		More: func(page directoryClientListFilesAndDirectoriesSegmentResponse) bool {
			return page.NextMarker != nil && len(*page.NextMarker) > 0
		},
		Fetcher: func(ctx context.Context, page *directoryClientListFilesAndDirectoriesSegmentResponse) (directoryClientListFilesAndDirectoriesSegmentResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listFilesAndDirectoriesSegmentCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextMarker)
			}
			if err != nil {
				return directoryClientListFilesAndDirectoriesSegmentResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return directoryClientListFilesAndDirectoriesSegmentResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return directoryClientListFilesAndDirectoriesSegmentResponse{}, runtime.NewResponseError(resp)
			}
			return client.listFilesAndDirectoriesSegmentHandleResponse(resp)
		},
	})
}

// listFilesAndDirectoriesSegmentCreateRequest creates the ListFilesAndDirectoriesSegment request.
func (client *directoryClient) listFilesAndDirectoriesSegmentCreateRequest(ctx context.Context, options *directoryClientListFilesAndDirectoriesSegmentOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "list")
	if options != nil && options.Prefix != nil {
		reqQP.Set("prefix", *options.Prefix)
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Include != nil {
		reqQP.Set("include", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.Include), "[]")), ","))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.IncludeExtendedInfo != nil {
		req.Raw().Header["x-ms-file-extended-info"] = []string{strconv.FormatBool(*options.IncludeExtendedInfo)}
	}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listFilesAndDirectoriesSegmentHandleResponse handles the ListFilesAndDirectoriesSegment response.
func (client *directoryClient) listFilesAndDirectoriesSegmentHandleResponse(resp *http.Response) (directoryClientListFilesAndDirectoriesSegmentResponse, error) {
	result := directoryClientListFilesAndDirectoriesSegmentResponse{}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientListFilesAndDirectoriesSegmentResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListFilesAndDirectoriesSegmentResponse); err != nil {
		return directoryClientListFilesAndDirectoriesSegmentResponse{}, err
	}
	return result, nil
}

// ListHandles - Lists handles for directory.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - directoryClientListHandlesOptions contains the optional parameters for the directoryClient.ListHandles method.
func (client *directoryClient) ListHandles(ctx context.Context, options *directoryClientListHandlesOptions) (directoryClientListHandlesResponse, error) {
	req, err := client.listHandlesCreateRequest(ctx, options)
	if err != nil {
		return directoryClientListHandlesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientListHandlesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientListHandlesResponse{}, runtime.NewResponseError(resp)
	}
	return client.listHandlesHandleResponse(resp)
}

// listHandlesCreateRequest creates the ListHandles request.
func (client *directoryClient) listHandlesCreateRequest(ctx context.Context, options *directoryClientListHandlesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodGet, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("comp", "listhandles")
	if options != nil && options.Marker != nil {
		reqQP.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Sharesnapshot != nil {
		reqQP.Set("sharesnapshot", *options.Sharesnapshot)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Recursive != nil {
		req.Raw().Header["x-ms-recursive"] = []string{strconv.FormatBool(*options.Recursive)}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// listHandlesHandleResponse handles the ListHandles response.
func (client *directoryClient) listHandlesHandleResponse(resp *http.Response) (directoryClientListHandlesResponse, error) {
	result := directoryClientListHandlesResponse{}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientListHandlesResponse{}, err
		}
		result.Date = &date
	}
	if err := runtime.UnmarshalAsXML(resp, &result.ListHandlesResponse); err != nil {
		return directoryClientListHandlesResponse{}, err
	}
	return result, nil
}

// SetMetadata - Updates user defined metadata for the specified directory.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// options - directoryClientSetMetadataOptions contains the optional parameters for the directoryClient.SetMetadata method.
func (client *directoryClient) SetMetadata(ctx context.Context, options *directoryClientSetMetadataOptions) (directoryClientSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, options)
	if err != nil {
		return directoryClientSetMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientSetMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientSetMetadataResponse{}, runtime.NewResponseError(resp)
	}
	return client.setMetadataHandleResponse(resp)
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *directoryClient) setMetadataCreateRequest(ctx context.Context, options *directoryClientSetMetadataOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.Metadata != nil {
		for k, v := range options.Metadata {
			req.Raw().Header["x-ms-meta-"+k] = []string{v}
		}
	}
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *directoryClient) setMetadataHandleResponse(resp *http.Response) (directoryClientSetMetadataResponse, error) {
	result := directoryClientSetMetadataResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return directoryClientSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// SetProperties - Sets properties on the directory.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2020-10-02
// fileAttributes - If specified, the provided file attributes shall be set. Default value: ‘Archive’ for file and ‘Directory’
// for directory. ‘None’ can also be specified as default.
// fileCreationTime - Creation time for the file/directory. Default value: Now.
// fileLastWriteTime - Last write time for the file/directory. Default value: Now.
// options - directoryClientSetPropertiesOptions contains the optional parameters for the directoryClient.SetProperties method.
func (client *directoryClient) SetProperties(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *directoryClientSetPropertiesOptions) (directoryClientSetPropertiesResponse, error) {
	req, err := client.setPropertiesCreateRequest(ctx, fileAttributes, fileCreationTime, fileLastWriteTime, options)
	if err != nil {
		return directoryClientSetPropertiesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return directoryClientSetPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return directoryClientSetPropertiesResponse{}, runtime.NewResponseError(resp)
	}
	return client.setPropertiesHandleResponse(resp)
}

// setPropertiesCreateRequest creates the SetProperties request.
func (client *directoryClient) setPropertiesCreateRequest(ctx context.Context, fileAttributes string, fileCreationTime string, fileLastWriteTime string, options *directoryClientSetPropertiesOptions) (*policy.Request, error) {
	req, err := runtime.NewRequest(ctx, http.MethodPut, client.endpoint)
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("restype", "directory")
	reqQP.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["x-ms-version"] = []string{"2020-10-02"}
	if options != nil && options.FilePermission != nil {
		req.Raw().Header["x-ms-file-permission"] = []string{*options.FilePermission}
	}
	if options != nil && options.FilePermissionKey != nil {
		req.Raw().Header["x-ms-file-permission-key"] = []string{*options.FilePermissionKey}
	}
	req.Raw().Header["x-ms-file-attributes"] = []string{fileAttributes}
	req.Raw().Header["x-ms-file-creation-time"] = []string{fileCreationTime}
	req.Raw().Header["x-ms-file-last-write-time"] = []string{fileLastWriteTime}
	req.Raw().Header["Accept"] = []string{"application/xml"}
	return req, nil
}

// setPropertiesHandleResponse handles the SetProperties response.
func (client *directoryClient) setPropertiesHandleResponse(resp *http.Response) (directoryClientSetPropertiesResponse, error) {
	result := directoryClientSetPropertiesResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientSetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return directoryClientSetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return directoryClientSetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-file-permission-key"); val != "" {
		result.FilePermissionKey = &val
	}
	if val := resp.Header.Get("x-ms-file-attributes"); val != "" {
		result.FileAttributes = &val
	}
	if val := resp.Header.Get("x-ms-file-creation-time"); val != "" {
		result.FileCreationTime = &val
	}
	if val := resp.Header.Get("x-ms-file-last-write-time"); val != "" {
		result.FileLastWriteTime = &val
	}
	if val := resp.Header.Get("x-ms-file-change-time"); val != "" {
		result.FileChangeTime = &val
	}
	if val := resp.Header.Get("x-ms-file-id"); val != "" {
		result.FileID = &val
	}
	if val := resp.Header.Get("x-ms-file-parent-id"); val != "" {
		result.FileParentID = &val
	}
	return result, nil
}
